/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./docs/_client/src/scss/reset.scss
var scss_reset = __webpack_require__(0);

// EXTERNAL MODULE: ./docs/_client/src/scss/index.scss
var scss = __webpack_require__(1);

// CONCATENATED MODULE: ./docs/_client/src/js/getClassnames.js
/**
 * Formats classnames from a given namespace
 * Essentially just adds a '.' to the beginning of classnames
 *
 * @param {Object} namespace The namespace within which to format classnames.
 * @return {Object}
 */
function getClassnames(namespace) {
  return Object.keys(namespace).reduce(function (acc, key) {
    acc[key] = ".".concat(namespace[key]);
    return acc;
  }, {});
}
// CONCATENATED MODULE: ./src/AriaComponent.js
/**
 * Class for facilitating accessible components.
 */
class AriaComponent {
  /**
   * Get the target element based on the controller's target attribute.
   *
   * @param  {HTMLElement} controller The components controlling element.
   * @return {HTMLElement|null}
   */
  static getTargetElement(controller) {
    if (! controller.hasAttribute('target')) {
      AriaComponent.configurationError(
        'The component element is missing the required \'target\' attribute'
      );
    }

    const targetId = controller.getAttribute('target');
    const target = document.getElementById(targetId);

    if (null === target) {
      AriaComponent.configurationError(
        `A target element with ID of '${targetId}' is not found`
      );
    }

    return target;
  }

  /**
   * Throw a confguration error.
   *
   * @param {string} message The error message.
   */
  static configurationError(message) {
    throw new Error(`Configuration error: ${message}`);
  }

  /**
   * Create an AriaComponent.
   * @constructor
   */
  constructor(element) {
    // Validate the component element.
    if (false === Boolean(element) || ! (element instanceof HTMLElement)) {
      AriaComponent.configurationError(
        'The component element must be a valid HTMLElement'
      );
    }

    /**
     * Component state.
     *
     * @type {object}
     */
    this.state = {};

    /**
     * Save search characters
     *
     * @type {string}
     */
    this.searchString = '';

    /**
     * Saved reference elements.
     *
     * @type {Array}
     */
    this.referenceElements = [];

    // Bind class methods.
    this.setState = this.setState.bind(this);
    this.getState = this.getState.bind(this);
    this.setSelfReference = this.setSelfReference.bind(this);
  }

  /**
   * Set component state.
   *
   * @param {object} newState The new state to merge with existing state.
   */
  setState(newState) {
    Object.assign(this.state, newState);

    if ('function' === typeof this.stateWasUpdated) {
      this.stateWasUpdated();
    }
  }

  /**
   * Set a reference to the class instance on the element upon which the class
   * is instantiated.
   *
   * @param {array} elements An array of elements upon which to add a reference to `this`.
   */
  setSelfReference(elements) {
    const referenceElements = [...elements].map((element) => {
      Object.defineProperty(
        element,
        this.componentName.toLowerCase(),
        { value: this, configurable: true }
      );

      return element;
    });

    this.referenceElements = [...this.referenceElements, ...referenceElements];
  }

  /**
   * Delete self references from component elements.
   */
  deleteSelfReferences() {
    this.referenceElements.forEach((element) => {
      delete element[this.componentName.toLowerCase()];
    });
  }

  /**
   * Return the current component state.
   *
   * @return {object}
   */
  getState() {
    return this.state;
  }
}

// CONCATENATED MODULE: ./src/lib/keyCodes.js
/**
 * Event keyCode values mapped to a key name.
 */
const keyCodes = Object.freeze({
  TAB: 9,
  RETURN: 13,
  ESC: 27,
  SPACE: 32,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
});

/* harmony default export */ var lib_keyCodes = (keyCodes);

// CONCATENATED MODULE: ./src/lib/interactiveChildren.js
/**
 * Collect all interactive child elements.
 *
 * @param {HTMLElement} target The element in which to search for interactive children.
 *
 * @return {Array}
 */
function interactiveChildren(target) {
  // List of possible active child element selectors
  const selectors = [
    'a[href]',
    'area[href]',
    'input:not([disabled])',
    'select:not([disabled])',
    'textarea:not([disabled])',
    'button:not([disabled])',
    'iframe',
    'object',
    'embed',
    '[contenteditable]',
    '[tabindex]:not([tabindex^="-"])',
  ].join(',');

  const interactiveElements = target.querySelectorAll(selectors);

  return Array.from(interactiveElements);
}

/* harmony default export */ var lib_interactiveChildren = (interactiveChildren);

// CONCATENATED MODULE: ./src/lib/toArray.js
/**
 * Create an array from a value.
 *
 * @param {Mixed} maybeAnArray An HTMLElement, NodeList, or Array of elements.
 */
function toArray(maybeAnArray) {
  if (Array.isArray(maybeAnArray)) {
    return maybeAnArray;
  }

  let shouldBeAnArray = [];

  if (maybeAnArray instanceof HTMLElement) {
    // Convert a single element to an Array.
    shouldBeAnArray = new Array(maybeAnArray);
  } else if (
    maybeAnArray instanceof NodeList
    || maybeAnArray instanceof HTMLCollection
  ) {
    shouldBeAnArray = Array.from(maybeAnArray);
  }

  return shouldBeAnArray;
}

// CONCATENATED MODULE: ./src/lib/rovingTabIndex.js


/**
 * Remove the tabIndex attribute from all elements.
 *
 * @param {Mixed} items An HTMLElement, NodeList, or array of elements.
 */
function tabIndexAllow(items) {
  const allowedElements = toArray(items);

  allowedElements.forEach((item) => {
    item.removeAttribute('tabindex');
  });
}

/**
 * Add a negative tabIndex attribute to all elements.
 *
 * @param {Mixed} items An HTMLElement, NodeList, or Array of elements.
 */
function tabIndexDeny(items) {
  const deniedElements = toArray(items);

  deniedElements.forEach((item) => {
    item.setAttribute('tabindex', '-1');
  });
}

/**
 * Manage items' tabindex.
 *
 * @param {NodeList|Array}             items The items whose tabindex may need updating.
 * @param {HTMLElement|NodeList|Array} allow The item to which we'll allow tabbing.
 */
function rovingTabIndex(items, allow) {
  const allowedElements = toArray(allow);
  const allItems = toArray(items);

  tabIndexAllow(allowedElements);

  if (0 < allItems.length) {
    const deniedElements = allItems.filter((item) => (
      ! allowedElements.includes(item)
    ));
    tabIndexDeny(deniedElements);
  }
}



// CONCATENATED MODULE: ./src/lib/uniqueId.js
/**
 * Create a passably unique `id` attribute.
 *
 * @param {Number} radix An optional base for converting the Number to a String.
 *
 * @returns {String}
 */
function getUniqueId(radix = 36) {
  const [, attr] = Math.random().toString(radix).split('.');
  return `id_${attr}`;
}

/**
 * Set the ID attribute if the element does not already have one.
 *
 * @param {HTMLElement} element the element upon which to act.
 */
function setUniqueId(element) {
  if (null !== element && '' === element.id) {
    element.setAttribute('id', getUniqueId());
  }
}



// CONCATENATED MODULE: ./src/lib/getFirstAndLastItems.js


/**
 * Get the first and last items from and Array or NodeList.
 *
 * @param  {array|NodeList} items The Array or NodeList from which to retrieve the items.
 * @return {array}                The first and last items.
 */
function getFirstAndLastItems(items) {
  // Ensure we're working with an Array;
  const arrayOfItems = toArray(items);
  const lastIndex = (arrayOfItems.length - 1);

  // Get the first and last items by index.
  const {
    0: firstItem,
    [lastIndex]: lastItem,
  } = arrayOfItems;

  return [firstItem, lastItem];
}

// CONCATENATED MODULE: ./src/Popup/index.js







/**
 * Class for setting up an interactive popup element that can be triggered by a
 * controlling element.
 */
class Popup_Popup extends AriaComponent {
  /**
   * Create a MenuBar.
   * @constructor
   *
   * @param {HTMLElement} controller The activating element.
   * @param {object}      options    The options object.
   */
  constructor(controller, options = {}) {
    super(controller);

    this.controller = controller;
    this.target = super.constructor.getTargetElement(controller);

    /**
     * The component name.
     *
     * @type {string}
     */
    this.componentName = 'Popup';

    /**
     * Component configuration options.
     *
     * @type {object}
     */
    const defaultOptions = {
      /**
       * The value of `aria-haspopup` must match the role of the Popup container.
       * Options: menu, listbox, tree, grid, or dialog,
       *
       * @type {string}
       */
      type: 'true', // 'true' === 'menu' in UAs that don't support WAI-ARIA 1.1

      /**
       * Callback to run after the component initializes.
       *
       * @callback initCallback
       */
      onInit: () => {},

      /**
       * Callback to run after component state is updated.
       *
       * @callback stateChangeCallback
       */
      onStateChange: () => {},

      /**
       * Callback to run after the component is destroyed.
       *
       * @callback destroyCallback
       */
      onDestroy: () => {},
    };

    // Save references to the controller and target.
    Object.assign(this, { ...defaultOptions, ...options });

    // Intial component state.
    this.state = { expanded: false };

    // Bind class methods.
    this.init = this.init.bind(this);
    this.stateWasUpdated = this.stateWasUpdated.bind(this);
    this.hide = this.hide.bind(this);
    this.show = this.show.bind(this);
    this.controllerHandleClick = this.controllerHandleClick.bind(this);
    this.controllerHandleKeydown = this.controllerHandleKeydown.bind(this);
    this.targetHandleKeydown = this.targetHandleKeydown.bind(this);
    this.hideOnTabOut = this.hideOnTabOut.bind(this);
    this.hideOnOutsideClick = this.hideOnOutsideClick.bind(this);
    this.destroy = this.destroy.bind(this);

    this.init();
  }

  /**
   * Set up the component's DOM attributes and event listeners.
   */
  init() {
    /*
     * A reference to the class instance added to the controller and target
     * elements to enable external interactions with this instance.
     */
    super.setSelfReference([this.controller, this.target]);

    /**
     * Collect the target element's interactive child elements.
     *
     * @type {array}
     */
    this.interactiveChildElements = lib_interactiveChildren(this.target);

    // Focusable content should initially have tabindex='-1'.
    tabIndexDeny(this.interactiveChildElements);

    /*
     * Collect first and last interactive child elements from target and merge
     * them in as instance properties.
     */
    if (0 < this.interactiveChildElements.length) {
      const [
        firstInteractiveChild,
        lastInteractiveChild,
      ] = getFirstAndLastItems(this.interactiveChildElements);

      Object.assign(this, { firstInteractiveChild, lastInteractiveChild });
    }

    // Add target attribute.
    setUniqueId(this.target);

    // Add controller attributes
    this.controller.setAttribute('aria-haspopup', this.type);
    this.controller.setAttribute('aria-expanded', 'false');
    this.controller.setAttribute('aria-controls', this.target.id);
    setUniqueId(this.controller);

    /**
     * Check if the controller is a button, but only if it doesn't already have
     * a role attribute, since we'll be adding the role and allowing focus.
     *
     * @type {bool}
     */
    this.controllerIsNotAButton = (
      'BUTTON' !== this.controller.nodeName
      && null === this.controller.getAttribute('role')
    );

    /*
     * Use the button role on non-button elements.
     */
    if (this.controllerIsNotAButton) {
      // https://www.w3.org/TR/wai-aria-1.1/#button
      this.controller.setAttribute('role', 'button');
      this.controller.setAttribute('tabindex', '0');
    }

    /*
     * Establishes a relationship when the DOM heirarchy doesn't represent that
     * a relationship exists.
     */
    if (this.target !== this.controller.nextElementSibling) {
      this.controller.setAttribute('aria-owns', this.target.id);
    }

    /*
     * Set the taget as hidden by default. Using the `aria-hidden` attribute,
     * rather than the `hidden` attribute, means authors must hide the target
     * element via CSS.
     */
    this.target.setAttribute('aria-hidden', 'true');
    this.target.setAttribute('hidden', '');

    // Add event listeners
    this.controller.addEventListener('click', this.controllerHandleClick);
    this.controller.addEventListener('keydown', this.controllerHandleKeydown);
    this.target.addEventListener('keydown', this.targetHandleKeydown);
    document.body.addEventListener('click', this.hideOnOutsideClick);

    // Run {initCallback}
    this.onInit.call(this);
  }

  /**
   * Update the component attributes based on updated state.
   *
   * @param {object} state The component state.
   */
  stateWasUpdated() {
    const { expanded } = this.state;

    this.controller.setAttribute('aria-expanded', `${expanded}`);

    /*
     * Update Popup and interactive children's attributes.
     */
    if (expanded) {
      this.target.setAttribute('aria-hidden', 'false');
      this.target.removeAttribute('hidden');

      tabIndexAllow(this.interactiveChildElements);
    } else {
      this.target.setAttribute('aria-hidden', 'true');
      this.target.setAttribute('hidden', '');

      // Focusable content should have tabindex='-1' or be removed from the DOM.
      tabIndexDeny(this.interactiveChildElements);
    }

    // Run {stateChangeCallback}
    this.onStateChange.call(this, this.state);
  }

  /**
   * Handle keydown events on the Popup controller.
   *
   * @param {Event} event The event object.
   */
  controllerHandleKeydown(event) {
    const { expanded } = this.state;
    const {
      ESC,
      TAB,
      SPACE,
      RETURN,
    } = lib_keyCodes;
    const { keyCode } = event;

    if ([SPACE, RETURN].includes(keyCode)) {
      /*
       * Treat the Spacebar and Return keys as clicks in case the controller is
       * not a <button>.
       */
      this.controllerHandleClick(event);
    } else if (expanded) {
      if (ESC === keyCode) {
        event.preventDefault();

        /*
         * Close the Popup when the Escape key is pressed. Because focus is not
         * inside the target (based on the fact that the event was fired on the
         * controller), there's no need to move focus.
         */
        this.hide();
      } else if (TAB === keyCode) {
        event.preventDefault();

        /*
         * When the Popup is open, pressing the TAB key should move focus to the
         * first interctive child of the target element. This would likely be
         * the default behavior in most cases, but this patches the behavior in
         * cases where the markup is disconnected or out-of-order.
         */
        this.firstInteractiveChild.focus();
      }
    }
  }

  /**
   * Handle keydown events on the Popup target.
   *
   * @param {Event} event The event object.
   */
  targetHandleKeydown(event) {
    const { ESC, TAB } = lib_keyCodes;
    const { keyCode, shiftKey } = event;
    const { expanded } = this.state;
    const { activeElement } = document;

    if (ESC === keyCode && expanded) {
      event.preventDefault();

      /*
       * Close the Popup when the Escape key is pressed.
       */
      this.hide();

      /*
       * Because the activeElement is within the Popup, move focus to the Popup
       * controller to avoid the confusion of focus being within a hidden
       * element.
       */
      this.controller.focus();
    } else if (TAB === keyCode) {
      if (shiftKey) {
        if ([this.firstInteractiveChild, this.target].includes(activeElement)) {
          event.preventDefault();
          /*
           * Move focus back to the controller if the Shift key is pressed with
           * the Tab key, but only if the Event target is the Popup's first
           * interactive child or the Popup itself.
           */
          this.controller.focus();
        }
      } else if (this.lastInteractiveChild === activeElement) {
        /*
         * Close the Popup when tabbing from the last child.
         */
        this.hide();
      }
    }
  }

  /**
   * Toggle the popup state.
   *
   * @param {Event} event The event object.
   */
  controllerHandleClick(event) {
    event.preventDefault();
    const { expanded } = this.state;

    this.setState({ expanded: ! expanded });
  }

  /**
   * Close the Popup if the Tab key is pressed and the last interactive child of
   * the Popup is the event target.
   *
   * @param {Event} event The event object.
   */
  hideOnTabOut(event) {
    const { expanded } = this.state;
    const { TAB } = lib_keyCodes;
    const { keyCode, shiftKey } = event;

    if (TAB === keyCode && ! shiftKey && expanded) {
      this.hide();
    }
  }

  /**
   * Close the Popup when clicking anywhere outside of the target or controller
   * elements.
   *
   * @param {Event} event The event object.
   */
  hideOnOutsideClick(event) {
    const { expanded } = this.state;
    const { target: clicked } = event;

    if (
      expanded
      && clicked !== this.controller
      && ! this.target.contains(clicked)
    ) {
      this.hide();
    }
  }

  /**
   * Remove all attributes and event listeners added by this class.
   */
  destroy() {
    // Remove the references to the class instance.
    this.deleteSelfReferences();

    // Remove IDs set by this class.
    [this.controller, this.target].forEach((element) => {
      if (element.getAttribute('id').includes('id_')) {
        element.removeAttribute('id');
      }
    });

    // Remove controller attributes.
    this.controller.removeAttribute('aria-haspopup');
    this.controller.removeAttribute('aria-expanded');
    this.controller.removeAttribute('aria-controls');
    this.controller.removeAttribute('aria-owns');

    // Remove role and tabindex added to a link controller.
    if (this.controllerIsNotAButton) {
      this.controller.removeAttribute('role');
      this.controller.removeAttribute('tabindex');
    }

    // Remove target attributes.
    this.target.removeAttribute('aria-hidden');
    this.target.removeAttribute('hidden');

    // Remove tabindex attribute.
    tabIndexAllow(this.interactiveChildElements);

    // Remove event listeners.
    this.controller.removeEventListener('click', this.controllerHandleClick);
    this.controller.removeEventListener(
      'keydown',
      this.controllerHandleKeydown
    );
    this.target.removeEventListener('keydown', this.targetHandleKeydown);
    document.body.removeEventListener('click', this.hideOnOutsideClick);

    // Reset initial state.
    this.state = { expanded: false };

    // Run {destroyCallback}
    this.onDestroy.call(this);
  }

  /**
   * Update component state to show the target element.
   */
  show() {
    this.setState({ expanded: true });
  }

  /**
   * Update component state to hide the target element.
   */
  hide() {
    this.setState({ expanded: false });
  }
}

// CONCATENATED MODULE: ./src/lib/Search.js
/**
 * Class for searching a list.
 */
class Search {
  /**
   * Create an instance of the Search class.
   * @constructor
   */
  constructor(items) {
    this.searchString = '';
    this.clearSearch = null;

    // Make sure `items` is an Array.
    switch (true) {
      case Array.isArray(items): {
        this.items = items;
        break;
      }
      case items instanceof NodeList: {
        this.items = Array.from(items);
        break;
      }
      case null !== items && 'UL' === items.nodeName: {
        this.items = Array.from(items.children);
        break;
      }
      default: {
        this.items = null;
        break;
      }
    }
  }

  /**
   * Select the item that matches a search string.
   * If a match is found, return it so that it can be selected.
   *
   * @param {Number} key A keyCode value.
   * @return {HTMLElement|null} The matched element or null if no match.
   */
  getItem(key) {
    if (null !== this.items) {
      const character = String.fromCharCode(key);

      // Append the new character to the searchString
      this.searchString += character;

      if (null !== this.clearSearch) {
        clearTimeout(this.clearSearch);
        this.clearSearch = null;
      }

      // Clear the typed string after timeout.
      this.clearSearch = setTimeout(() => {
        this.searchString = '';
        this.clearSearch = null;
      }, 500);

      // Find the item by matching the search string to the item text.
      const match = this.items.filter((item) => {
        const itemText = item.textContent.toLowerCase();
        return 0 === itemText.indexOf(this.searchString.toLowerCase());
      });

      return match.length ? match[0] : null;
    }

    return null;
  }
}

// CONCATENATED MODULE: ./src/Listbox/index.js







/**
 * Class to set up an interactive Listbox element.
 *
 * https://www.w3.org/TR/wai-aria-practices-1.1/#Listbox
 */
class Listbox_ListBox extends AriaComponent {
  /**
   * Create a ListBox.
   * @constructor
   *
   * @param {HTMLElement} controller The activating element.
   * @param {object}      options    The options object.
   */
  constructor(controller, options = {}) {
    super(controller);

    this.controller = controller;
    this.target = super.constructor.getTargetElement(controller);

    /**
     * The component name.
     *
     * @type {string}
     */
    this.componentName = 'ListBox';

    /**
     * Options shape.
     *
     * @type {object}
     */
    const defaultOptions = {
      /**
       * Callback to run after the component initializes.
       *
       * @callback initCallback
       */
      onInit: () => {},

      /**
       * Callback to run after component state is updated.
       *
       * @callback stateChangeCallback
       */
      onStateChange: () => {},

      /**
       * Callback to run after the component is destroyed.
       *
       * @callback destroyCallback
       */
      onDestroy: () => {},
    };

    // Merge options with defaults.
    Object.assign(this, { ...defaultOptions, ...options });

    // Bind class methods.
    this.preventWindowScroll = this.preventWindowScroll.bind(this);
    this.controllerHandleKeyup = this.controllerHandleKeyup.bind(this);
    this.targetHandleKeydown = this.targetHandleKeydown.bind(this);
    this.targetHandleClick = this.targetHandleClick.bind(this);
    this.targetHandleBlur = this.targetHandleBlur.bind(this);
    this.scrollOptionIntoView = this.scrollOptionIntoView.bind(this);
    this.onPopupStateChange = this.onPopupStateChange.bind(this);
    this.show = this.show.bind(this);
    this.hide = this.hide.bind(this);
    this.destroy = this.destroy.bind(this);
    this.stateWasUpdated = this.stateWasUpdated.bind(this);

    this.init();
  }

  /**
   * Set up the component's DOM attributes and event listeners.
   */
  init() {
    /*
     * A reference to the class instance added to the controller and target
     * elements to enable external interactions with this instance.
     */
    super.setSelfReference([this.controller, this.target]);

    /**
     * The target list items.
     *
     * @type {array}
     */
    this.options = Array.from(this.target.children);

    /**
     * Initialize search.
     * @type {Search}
     */
    this.search = new Search(this.options);

    /*
     * Set the `option` role for each list itme and ensure each has a unique ID.
     * The ID here is what will be used to track the active descendant.
     */
    this.options.forEach((listItem) => {
      setUniqueId(listItem);
      listItem.setAttribute('role', 'option');
    });

    // Save first and last option as properties.
    const [firstOption, lastOption] = getFirstAndLastItems(this.options);
    Object.assign(this, { firstOption, lastOption });

    /**
     * The initial default state.
     *
     * The element is saved, rather than just its ID attribute, to remove the
     * need to query the DOM for it each time we need to act on it.
     *
     * @type {HTMLElement}
     */
    this.state = { activeDescendant: this.firstOption };

    /**
     * The Listbox is basically a Popup to present a list of options, so we
     * instantiate a Popup and subscribe to state changes to act on the Listbox
     * when the Popup is shown and hidden.
     *
     * @type {Popup}
     */
    this.popup = new Popup_Popup(
      this.controller,
      {
        type: 'listbox',
        onStateChange: this.onPopupStateChange,
      }
    );

    /*
     * Add the 'listbox' role to signify a component that presents a listbox of
     * options from which to select.
     */
    this.target.setAttribute('role', 'listbox');

    /*
     * Set up the target element to allow programatically setting focus to it
     * when the Listbox opens.
     *
     * @see this.stateWasUpdated()
     */
    this.target.setAttribute('tabindex', '-1');

    // Add event listeners.
    this.controller.addEventListener('keydown', this.controllerHandleKeyup);
    this.target.addEventListener('keydown', this.targetHandleKeydown);
    this.target.addEventListener('click', this.targetHandleClick);
    this.target.addEventListener('blur', this.targetHandleBlur);

    // Prevent scrolling when using UP/DOWN arrows on the button
    window.addEventListener('keydown', this.preventWindowScroll);

    // Run {initCallback}
    this.onInit.call(this);
  }

  /**
   * Track the selected Listbox option.
   * https://www.w3.org/TR/wai-aria-practices-1.1/#kbd_focus_activedescendant
   *
   * @param {object} state The component state.
   * @param {HTMLElement} state.activeDescendant The expected `activeDescendant` state.
   */
  stateWasUpdated() {
    const { activeDescendant, expanded } = this.state;

    if (expanded) {
      /*
       * Remove the `aria-selected` attribute from the previously-selected option
       * and add it to the newly-selected option.
       */
      const selected = this.target.querySelector('[aria-selected="true"]');
      if (null !== selected) {
        selected.removeAttribute('aria-selected');
      }
      activeDescendant.setAttribute('aria-selected', 'true');

      /*
       * Track the newly selected option via the `aria-activedescendant` attribute
       * on the target.
       */
      this.target.setAttribute('aria-activedescendant', activeDescendant.id);

      /*
       * If the selected option is beyond the bounds of the list, scroll it into
       * view. Check this every time state is updated to ensure the selected
       * option is always visible.
       */
      this.scrollOptionIntoView(activeDescendant);
    }

    // Run {stateChangeCallback}
    this.onStateChange.call(this, this.state);
  }

  /**
   * Subscribe to Popup state changes.
   *
   * @param {object} popup.state the Popup state.
   * @param {boolean} popup.state.expanded The Popup `expanded` state.
   */
  onPopupStateChange({ expanded }) {
    const { activeDescendant } = this.state;

    if (expanded) {
      /*
       * Focus the target (list) element when the Listbox is shown. Focus
       * remains on the target element, with option selection coming through a
       * combination of the `aria-selected` attribute on the option and the
       * `aria-activedescendant` attribute on the target tracking the active
       * option.
       */
      this.target.focus();
    } else {
      /*
       * When the Popup is hidden, the `aria-activedescendant` attribute should
       * be removed from the list and the selected option should be used as the
       * button text.
       */
      this.target.removeAttribute('aria-activedescendant');
      this.controller.textContent = activeDescendant.textContent;

      /*
       * If focus is within the Listbox, move focus to the controller. This
       * check is in place to avoid moving focus to the controller if an element
       * outside of the Listbox is clicked.
       */
      if (this.target.contains(document.activeElement)) {
        this.controller.focus();
      }
    }

    // Update component state.
    this.setState({ activeDescendant, expanded });
  }

  /**
   * Prevent the page from scrolling when the arrow keys are used.
   *
   * @param {Event} event The event object.
   */
  preventWindowScroll(event) {
    const { UP, DOWN } = lib_keyCodes;
    const { target: keydownTarget, keyCode } = event;

    if (keydownTarget === this.target && [UP, DOWN].includes(keyCode)) {
      event.preventDefault();
    }
  }

  /**
   * Handle keyup events on the button.
   * Both the UP and DOWN arrow keys should show the Listbox popup.
   *
   * @param {Event} event The event object.
   */
  controllerHandleKeyup(event) {
    const { UP, DOWN } = lib_keyCodes;

    if ([UP, DOWN].includes(event.keyCode)) {
      event.preventDefault();

      this.show();
    }
  }

  /**
   * Handle keydown events on the listbox.
   *
   * @param {Event} event The event object.
   */
  targetHandleKeydown(event) {
    const { activeDescendant } = this.state;
    const { keyCode } = event;
    const {
      RETURN,
      ESC,
      UP,
      DOWN,
      SPACE,
      HOME,
      END,
    } = lib_keyCodes;

    switch (keyCode) {
      /*
       * Close the Listbox when the Return, Escape, or Spacebar are pressed. No
       * need to update state here; if the Listbox is open rest assured an
       * option is selected.
       */
      case ESC:
      case RETURN:
      case SPACE: {
        event.preventDefault();
        this.hide();

        // Move focus to the controller when the Listbox is closed.
        this.controller.focus();

        break;
      }

      /*
       * Select the next or previous Listbox option.
       */
      case UP:
      case DOWN: {
        let moveTo = activeDescendant;

        moveTo = (keyCode === UP)
          ? moveTo.previousElementSibling
          : moveTo.nextElementSibling;

        if (moveTo) {
          event.preventDefault();
          this.setState({ activeDescendant: moveTo });
        }

        break;
      }

      /*
       * Select the first Listbox option.
       */
      case HOME: {
        event.preventDefault();
        this.setState({ activeDescendant: this.firstOption });

        break;
      }

      /*
       * Select the last Listbox option.
       */
      case END: {
        event.preventDefault();
        this.setState({ activeDescendant: this.lastOption });

        break;
      }

      /*
       * Select the Listbox option based on a search string created by
       * collecting key presses.
       */
      default: {
        const itemToFocus = this.search.getItem(keyCode);
        if (null !== itemToFocus) {
          this.setState({ activeDescendant: itemToFocus });
        }

        break;
      }
    }
  }

  /**
   * Close the Listbox, but not before updating state to reflect the option that
   * was clicked.
   *
   * @param {Event} event The event object.
   */
  targetHandleClick(event) {
    this.setState({ activeDescendant: event.target });
    this.hide();
  }

  /**
   * Close the Listbox when focus is moved away from the target.
   */
  targetHandleBlur() {
    // Use Popup state here, since the Popup drives the Listbox state.
    if (this.popup.getState().expanded) {
      this.hide();
    }
  }

  /**
   * If the Listbox is scrollable, and the selected option is not visible,
   * scroll it into view.
   *
   * @param {HTMLElement} moveTo The element getting focus.
   */
  scrollOptionIntoView(moveTo) {
    const { scrollHeight, clientHeight, scrollTop } = this.target;
    const { offsetTop, offsetHeight } = moveTo;

    if (scrollHeight > clientHeight) {
      const scrollBottom = clientHeight + scrollTop;
      const elementBottom = offsetTop + offsetHeight;

      if (elementBottom > scrollBottom) {
        this.target.scrollTop = elementBottom - clientHeight;
      } else if (offsetTop < scrollTop) {
        this.target.scrollTop = offsetTop;
      }
    }
  }

  /**
   * Destroy the Listbox and Popup.
   */
  destroy() {
    // Remove the references to the class instance.
    this.deleteSelfReferences();

    // Remove the role attribute from each of the options.
    this.options.forEach((listItem) => {
      listItem.removeAttribute('role');
      listItem.removeAttribute('aria-selected');

      // Remove IDs set by this class.
      if (listItem.getAttribute('id').includes('id_')) {
        listItem.removeAttribute('id');
      }
    });

    // Destroy the Popup.
    this.popup.destroy();

    // Remove the listbox role.
    this.target.removeAttribute('role');
    this.target.removeAttribute('tabindex');
    this.target.removeAttribute('aria-activedescendant');

    // Remove event listeners.
    this.controller.removeEventListener('keyup', this.controllerHandleKeyup);
    this.target.removeEventListener('keydown', this.targetHandleKeydown);
    this.target.removeEventListener('click', this.targetHandleClick);
    this.target.removeEventListener('blur', this.targetHandleBlur);
    window.removeEventListener('keydown', this.preventWindowScroll);

    // Run {destroyCallback}
    this.onDestroy.call(this);
  }

  /**
   * Show the Listbox.
   */
  show() {
    this.popup.show();
  }

  /**
   * Hide the Listbox.
   */
  hide() {
    this.popup.hide();
  }
}

// CONCATENATED MODULE: ./src/Disclosure/index.js






/**
 * Class to set up a controller-target relationship for independently revealing
 * and hiding inline content.
 *
 * https://www.w3.org/TR/wai-aria-practices-1.1/#disclosure
 */
class Disclosure_Disclosure extends AriaComponent {
  /**
   * Create a Disclosure.
   * @constructor
   *
   * @param {HTMLElement} controller The activating element.
   * @param {object}      options    The options object.
   */
  constructor(controller, options = {}) {
    super(controller);

    this.controller = controller;
    this.target = super.constructor.getTargetElement(controller);

    /**
     * The component name.
     *
     * @type {string}
     */
    this.componentName = 'Disclosure';

    /**
     * Options shape.
     *
     * @type {object}
     */
    const defaultOptions = {
      /**
       * Load the Disclosure open by default.
       *
       * @type {boolean}
       */
      loadOpen: false,

      /**
       * Keep the Disclosure open when the user clicks outside of it.
       *
       * @type {boolean}
       */
      allowOutsideClick: true,

      /**
       * Callback to run after the component initializes.
       *
       * @callback initCallback
       */
      onInit: () => {},

      /**
       * Callback to run after component state is updated.
       *
       * @callback stateChangeCallback
       */
      onStateChange: () => {},

      /**
       * Callback to run after the component is destroyed.
       *
       * @callback destroyCallback
       */
      onDestroy: () => {},
    };

    // Merge options with defaults and save all as instance properties.
    Object.assign(this, { ...defaultOptions, ...options });

    // Initial component state.
    this.state = { expanded: this.loadOpen };

    // Bind class methods.
    this.init = this.init.bind(this);
    this.destroy = this.destroy.bind(this);
    this.open = this.open.bind(this);
    this.close = this.close.bind(this);
    this.controllerHandleKeydown = this.controllerHandleKeydown.bind(this);
    this.toggleExpandedState = this.toggleExpandedState.bind(this);
    this.closeOnOutsideClick = this.closeOnOutsideClick.bind(this);
    this.stateWasUpdated = this.stateWasUpdated.bind(this);

    this.init();
  }

  /**
   * Add initial attributes, establish relationships, and listen for events
   */
  init() {
    /*
     * A reference to the class instance added to the controller and target
     * elements to enable external interactions with this instance.
     */
    super.setSelfReference([this.controller, this.target]);

    // Component state is initially set in the constructor.
    const { expanded } = this.state;

    /**
     * Collect the target element's interactive child elements.
     * @type {array}
     */
    this.interactiveChildElements = lib_interactiveChildren(this.target);

    // Ensure the target and controller each have an ID attribute.
    [this.controller, this.target].forEach((element) => {
      setUniqueId(element);
    });

    // Add controller attributes
    this.controller.setAttribute('aria-expanded', `${expanded}`);
    this.controller.setAttribute('aria-controls', this.target.id);

    // Patch button role and behavior for non-button controller.
    if ('BUTTON' !== this.controller.nodeName) {
      /*
       * Some elements semantics conflict with the button role. You really
       * should just use a button.
       */
      this.controller.setAttribute('role', 'button');

      // Ensure we can TAB to the controller if it's not a button or anchor.
      if (
        'A' !== this.controller.nodeName
        && null === this.controller.getAttribute('tabindex')
      ) {
        this.controller.setAttribute('tabindex', '0');
      }
    }

    /*
     * Establishes a relationship when the DOM heirarchy doesn't represent that
     * a relationship exists.
     */
    if (this.target !== this.controller.nextElementSibling) {
      this.controller.setAttribute('aria-owns', this.target.id);
    }

    /*
     * Set the taget as hidden by default. Using the `aria-hidden` attribute,
     * rather than the `hidden` attribute, means authors must hide the target
     * element via CSS.
     */
    if (! expanded) {
      this.target.setAttribute('aria-hidden', 'true');
      this.target.setAttribute('hidden', '');
    }

    // Add event listeners
    this.controller.addEventListener('click', this.toggleExpandedState);
    this.controller.addEventListener('keydown', this.controllerHandleKeydown);
    if (! this.allowOutsideClick) {
      document.body.addEventListener('click', this.closeOnOutsideClick);
    }

    /*
     * Prevent focus on interactive elements in the target when the target is
     * hidden. This isn't such an issue when the target is hidden with
     * `display:none`, but is necessary if the target is hidden by other means,
     * such as minimized height or width.
     */
    tabIndexDeny(this.interactiveChildElements);

    // Run {initCallback}
    this.onInit.call(this);
  }

  /**
   * Update the component attributes based on updated state.
   *
   * @param {object} state The component state.
   * @param {boolean} state.expanded The expected `expanded` state.
   */
  stateWasUpdated() {
    const { expanded } = this.state;

    this.controller.setAttribute('aria-expanded', `${expanded}`);

    /*
     * https://developer.paciellogroup.com/blog/2016/01/the-state-of-hidden-content-support-in-2016/
     *
     * > In some browser and screen reader combinations aria-hidden=false on an
     *   element that is hidden using the hidden attribute or CSS display:none
     *   results in the content being unhidden.
     */
    if (expanded) {
      this.target.setAttribute('aria-hidden', 'false');
      this.target.removeAttribute('hidden');
    } else {
      this.target.setAttribute('aria-hidden', 'true');
      this.target.setAttribute('hidden', '');
    }

    // Allow or deny keyboard focus depending on component state.
    if (expanded) {
      tabIndexAllow(this.interactiveChildElements);
    } else {
      tabIndexDeny(this.interactiveChildElements);
    }

    // Run {stateChangeCallback}
    this.onStateChange.call(this, this.state);
  }

  /**
   * Handle keydown events on the Disclosure controller.
   *
   * @param {Event} event The event object.
   */
  controllerHandleKeydown(event) {
    const { SPACE, RETURN } = lib_keyCodes;
    const { keyCode } = event;

    if ([SPACE, RETURN].includes(keyCode)) {
      /*
       * Treat the Spacebar and Return keys as clicks in case the controller is
       * not a <button>.
       */
      this.toggleExpandedState(event);
    }
  }

  /**
   * Toggle the expanded state.
   *
   * @param {Event} event The Event object.
   */
  toggleExpandedState(event) {
    event.preventDefault();

    if (this.state.expanded) {
      this.close();
    } else {
      this.open();
    }
  }

  /**
   * Close the disclosure when the user clicks outside of the target.
   *
   * @param {Event} event The Event object.
   */
  closeOnOutsideClick(event) {
    if (
      this.state.expanded
      && event.target !== this.controller
      && ! this.target.contains(event.target)
    ) {
      this.close();
    }
  }

  /**
   * Remove all ARIA attributes added by this class.
   */
  destroy() {
    // Remove the references to the class instance.
    this.deleteSelfReferences();

    // Remove IDs set by this class.
    [this.controller, this.target].forEach((element) => {
      if (element.getAttribute('id').includes('id_')) {
        element.removeAttribute('id');
      }
    });

    // Remove controller attributes.
    this.controller.removeAttribute('aria-expanded');
    this.controller.removeAttribute('aria-controls');
    this.controller.removeAttribute('aria-owns');
    this.controller.removeAttribute('tabindex');

    if ('BUTTON' !== this.controller.nodeName) {
      this.controller.removeAttribute('role');
    }

    // Remove target attributes.
    this.target.removeAttribute('aria-hidden');
    this.target.removeAttribute('hidden');

    // Remove tabindex attributes.
    tabIndexAllow(this.interactiveChildElements);

    // Remove event listeners.
    this.controller.removeEventListener('click', this.toggleExpandedState);
    this.controller.removeEventListener(
      'keydown',
      this.controllerHandleKeydown
    );
    document.body.removeEventListener('click', this.closeOnOutsideClick);

    // Reset initial state.
    this.state = { expanded: this.loadOpen };

    // Run {destroyCallback}
    this.onDestroy.call(this);
  }

  /**
   * Update component state to open the Disclosure.
   */
  open() {
    this.setState({ expanded: true });
  }

  /**
   * Update component state to close the Disclosure.
   */
  close() {
    this.setState({ expanded: false });
  }
}

// CONCATENATED MODULE: ./src/lib/isInstanceOf.js
/**
 * Check if a given element's property has been instantiated as an AriaComponent class.
 *
 * @param {HTMLElement} prop      The property to check.
 * @param {Object}      component The class instance to check against.
 * @return {Boolean}
 */
function isInstanceOf(prop, component) {
  if (undefined === prop || null === prop) {
    return false;
  }

  return (prop instanceof component);
}

// CONCATENATED MODULE: ./src/lib/nextPrevious.js


function nextPrevious(keyCode, activeDescendant, menuItems, keys) {
  const { next, previous } = keys;
  const activeIndex = menuItems.indexOf(activeDescendant);
  const menuLastIndex = menuItems.length - 1;

  // Determine the direction.
  let newIndex = (keyCode === previous) ? activeIndex - 1 : activeIndex + 1;

  // Move to the end if we're moving to the previous child from the first child.
  if (previous === keyCode && 0 > newIndex) {
    newIndex = menuLastIndex;
  }

  // Move to first child if we're at the end.
  if (next === keyCode && menuLastIndex < newIndex) {
    newIndex = 0;
  }

  return menuItems[newIndex];
}

function nextPreviousFromUpDown(keyCode, activeDescendant, menuItems) {
  const { UP, DOWN } = lib_keyCodes;
  return nextPrevious(
    keyCode,
    activeDescendant,
    menuItems,
    { previous: UP, next: DOWN }
  );
}

function nextPreviousFromLeftRight(keyCode, activeDescendant, menuItems) {
  const { LEFT, RIGHT } = lib_keyCodes;
  return nextPrevious(
    keyCode,
    activeDescendant,
    menuItems,
    { previous: LEFT, next: RIGHT }
  );
}



// CONCATENATED MODULE: ./src/Menu/index.js








/**
 * Class to set up an vertically oriented interactive Menu element.
 *
 * https://www.w3.org/TR/wai-aria-practices-1.1/#menu
 */
class Menu_Menu extends AriaComponent {
  /**
   * Test for a list as the next sibling element.
   *
   * @param {HTMLElement} element The element whose sibling we're testing.
   * @return {HTMLElement|boolean}
   */
  static nextElementIsUl(element) {
    const next = element.nextElementSibling;
    return (null !== next && 'UL' === next.nodeName) ? next : false;
  }

  /**
   * Create a Menu.
   * @constructor
   *
   * @param {HTMLUListElement} element The menu list element.
   * @param {object}           options The options object.
   */
  constructor(list, options = {}) {
    super(list);

    if ('UL' !== list.nodeName) {
      AriaComponent.configurationError(
        'The Menu element nodeName must be `UL`'
      );
    }

    this.list = list;

    /**
     * The component name.
     *
     * @type {string}
     */
    this.componentName = 'Menu';

    /**
     * Options shape.
     *
     * @type {object}
     */
    const defaultOptions = {
      /**
       * Instantiate submenus as Disclosures.
       *
       * @type {Boolean}
       */
      collapse: false,

      /**
       * Selector used to validate menu items.
       *
       * This can also be used to exclude items that would otherwise be given a
       * "menuitem" role; e.g., `:not(.hidden)`.
       *
       * @type {string}
       */
      itemMatches: '*',

      /**
       * Callback to run after the component initializes.
       *
       * @callback initCallback
       */
      onInit: () => {},

      /**
       * Callback to run after the component is destroyed.
       *
       * @callback destroyCallback
       */
      onDestroy: () => {},
    };

    // Merge options with defaults.
    Object.assign(this, { ...defaultOptions, ...options });

    // Bind class methods
    this.listHandleKeydown = this.listHandleKeydown.bind(this);
    this.destroy = this.destroy.bind(this);

    this.init();
  }

  /**
   * Collect menu links and recursively instantiate sublist menu items.
   */
  init() {
    /*
     * A reference to the class instance added to the controller and target
     * elements to enable external interactions with this instance.
     */
    super.setSelfReference([this.list]);

    /*
     * Add the 'menu' role to signify a widget that offers a list of choices to
     * the user, such as a set of actions or functions.
     */
    this.list.setAttribute('role', 'menu');

    /**
     * The list's child elements.
     *
     * @type {array}
     */
    this.listItems = Array.from(this.list.children);

    /**
     * Collected menu links.
     *
     * @type {array}
     */
    this.menuItems = this.listItems.reduce((acc, item) => {
      const [firstChild, ...theRest] = Array.from(item.children);

      // Try to use the first child of the menu item.
      let itemLink = firstChild;

      // If the first child isn't a link or button, find the first instance of either.
      if (null === itemLink || ! itemLink.matches('a,button')) {
        [itemLink] = Array.from(theRest)
          .filter((child) => child.matches('a,button'));
      }

      if (undefined !== itemLink && itemLink.matches(this.itemMatches)) {
        return [...acc, itemLink];
      }

      return acc;
    }, []);

    /**
     * Initialize search.
     * @type {Search}
     */
    this.search = new Search(this.menuItems);

    /**
     * The number of menu items.
     *
     * @type {number}
     */
    this.menuItemsLength = this.menuItems.length;

    /**
     * Listen for keydown events on the menu.
     */
    this.list.addEventListener('keydown', this.listHandleKeydown);

    /**
     * The submenu Disclosures.
     *
     * @type {array}
     */
    this.disclosures = [];

    /*
     * Set menu link attributes and instantiate submenus.
     */
    this.menuItems.forEach((link, index) => {
      // Remove semantics from list items.
      link.parentElement.setAttribute('role', 'presentation');

      // Set the menuitem role.
      link.setAttribute('role', 'menuitem');

      // Add size and position attributes.
      link.setAttribute('aria-setsize', this.menuItemsLength);
      link.setAttribute('aria-posinset', index + 1);

      // Instantiate submenu Disclosures
      if (this.collapse && link.hasAttribute('target')) {
        const disclosure = new Disclosure_Disclosure(link);

        this.disclosures.push(disclosure);
      }

      const siblingList = this.constructor.nextElementIsUl(link);
      if (siblingList) {
        // Instantiate sub-Menus.
        const subList = new Menu_Menu(siblingList);
        // Save the list's previous sibling.
        subList.previousSibling = link;
      }
    });

    // Save the menu's first and last items.
    const [firstItem, lastItem] = getFirstAndLastItems(this.menuItems);
    Object.assign(this, { firstItem, lastItem });

    // Run {initCallback}
    this.onInit.call(this);
  }

  /**
   * Handle keydown events on menu items.
   *
   * @param {Event} event The event object.
   */
  listHandleKeydown(event) {
    const { keyCode } = event;
    const {
      UP,
      DOWN,
      LEFT,
      RIGHT,
      HOME,
      END,
      ESC,
    } = lib_keyCodes;
    const { activeElement } = document;
    const activeDescendant = (this.list.contains(activeElement)
      ? activeElement
      : this.menuItems[0]);

    switch (keyCode) {
      /*
       * Move through sibling list items.
       */
      case UP:
      case DOWN: {
        const nextItem = nextPreviousFromUpDown(
          keyCode,
          activeDescendant,
          this.menuItems
        );

        if (nextItem) {
          event.stopPropagation();
          event.preventDefault();

          nextItem.focus();
        }

        break;
      }

      /*
       * Select the first Menu item.
       */
      case HOME: {
        event.preventDefault();

        this.firstItem.focus();

        break;
      }

      /*
       * Select the last Menu item.
       */
      case END: {
        event.preventDefault();

        this.lastItem.focus();

        break;
      }

      /*
       * Drill down into a nested list, if present.
       */
      case RIGHT: {
        const siblingElement = this.constructor.nextElementIsUl(activeDescendant); // eslint-disable-line max-len

        if (siblingElement && isInstanceOf(siblingElement.menu, Menu_Menu)) {
          event.stopPropagation();
          event.preventDefault();

          // Open the submenu Disclosure.
          if (isInstanceOf(activeDescendant.disclosure, Disclosure_Disclosure)) {
            activeDescendant.disclosure.open();
          }

          const { menu } = siblingElement;
          menu.firstItem.focus();
        }

        break;
      }

      /*
       * Move up to the list's previous sibling, if present.
       */
      case LEFT: {
        if (
          undefined !== this.previousSibling
          && ! this.previousSibling.hasAttribute('aria-haspopup')
        ) {
          // The previous sibling is not a Popup.
          event.preventDefault();
          event.stopPropagation();

          // Close the submenu Disclosure.
          if (isInstanceOf(this.previousSibling.disclosure, Disclosure_Disclosure)) {
            this.previousSibling.disclosure.close();
          }

          this.previousSibling.focus();
        }

        break;
      }

      /*
       * Listen for the ESC key to prevent it from being caught as a search
       * string. Otherwise the MenuButton won't close as expected.
       */
      case ESC: {
        // do nothing.
        break;
      }

      /*
       * Select the Menu item based on a search string created by
       * collecting key presses.
       */
      default: {
        event.stopPropagation();
        const itemToFocus = this.search.getItem(keyCode);
        if (null !== itemToFocus) {
          itemToFocus.focus();
        }

        break;
      }
    }
  }

  /**
   * Destroy the Menu and any submenus.
   */
  destroy() {
    // Remove the reference to the class instance.
    this.deleteSelfReferences();

    // Remove the list's role attritbute.
    this.list.removeAttribute('role');

    // Remove event listener.
    this.list.removeEventListener('keydown', this.listHandleKeydown);

    this.menuItems.forEach((link) => {
      // Remove list item role.
      link.parentElement.removeAttribute('role');

      // Remove menuitem attributes.
      link.removeAttribute('role');
      link.removeAttribute('aria-setsize');
      link.removeAttribute('aria-posinset');

      // Destroy nested Menus.
      const siblingList = this.constructor.nextElementIsUl(link);
      if (siblingList && isInstanceOf(siblingList.menu, Menu_Menu)) {
        siblingList.menu.destroy();
      }
    });

    // Destroy inner Disclosure(s).
    this.disclosures.forEach((disclosure) => {
      disclosure.destroy();
    });

    // Run {destroyCallback}
    this.onDestroy.call(this);
  }
}

// CONCATENATED MODULE: ./src/MenuBar/index.js










/**
 * Class for managing a visually persistent (horizontally-oriented) menubar,
 * with each submenu item is instantiated as a Popup.
 *
 * https://www.w3.org/TR/wai-aria-practices-1.1/#menu
 * https://www.w3.org/TR/wai-aria-1.1/#menubar
 */
class MenuBar_MenuBar extends AriaComponent {
  /**
   * Save the menuBar item's popup, if it exists.
   *
   * @param {HTMLElement} menubarItem The current menubarItem from state.
   * @return {Popup|Boolean} The menubarItem's popup, or false if none.
   */
  static getPopupFromMenubarItem(menubarItem) {
    return isInstanceOf(menubarItem.popup, Popup_Popup)
      ? menubarItem.popup
      : false;
  }

  /**
   * Create a MenuBar.
   * @constructor
   *
   * @param {HTMLUListElement} element The menu list element.
   * @param {object}           options The options object.
   */
  constructor(list, options = {}) {
    super(list);

    if ('UL' !== list.nodeName) {
      AriaComponent.configurationError(
        'The MenuBar element nodeName must be `UL`'
      );
    }

    this.list = list;

    /**
     * The component name.
     *
     * @type {string}
     */
    this.componentName = 'MenuBar';

    /**
     * Options shape.
     *
     * @type {object}
     */
    const defaultOptions = {
      /**
       * Selector used to validate menu items.
       *
       * This can also be used to exclude items that would otherwise be given a
       * "menuitem" role; e.g., `:not(.hidden)`.
       *
       * @type {string}
       */
      itemMatches: '*',

      /**
       * Callback to run after the component initializes.
       *
       * @callback initCallback
       */
      onInit: () => {},

      /**
       * Callback to run after component state is updated.
       *
       * @callback stateChangeCallback
       */
      onStateChange: () => {},

      /**
       * Callback to run after the component is destroyed.
       *
       * @callback destroyCallback
       */
      onDestroy: () => {},

      /**
       * Callback to run after Popup initializes.
       *
       * @callback popupInitCallback
       */
      onPopupInit: () => {},
    };

    // Merge options with defaults.
    Object.assign(this, { ...defaultOptions, ...options });

    // Bind class methods.
    this.menubarHandleKeydown = this.menubarHandleKeydown.bind(this);
    this.menubarHandleClick = this.menubarHandleClick.bind(this);
    this.menuItemHandleKeydown = this.menuItemHandleKeydown.bind(this);
    this.stateWasUpdated = this.stateWasUpdated.bind(this);
    this.destroy = this.destroy.bind(this);

    this.init();
  }

  /**
   * Collect top-level menu items and set up event handlers.
   */
  init() {
    /*
     * A reference to the class instance added to the controller and target
     * elements to enable external interactions with this instance.
     */
    super.setSelfReference([this.list]);

    // Set the menu role.
    this.list.setAttribute('role', 'menubar');

    /**
     * The menubar's child elements.
     *
     * @type {array}
     */
    this.menuBarChildren = Array.from(this.list.children);

    /**
     * Collected menubar links.
     *
     * @type {array}
     */
    this.menuBarItems = this.menuBarChildren.reduce((acc, item) => {
      const [firstChild, ...theRest] = Array.from(item.children);

      // Try to use the first child of the menu item.
      let itemLink = firstChild;

      // If the first child isn't a link or button, find the first instance of either.
      if (null === itemLink || ! itemLink.matches('a,button')) {
        [itemLink] = Array.from(theRest)
          .filter((child) => child.matches('a,button'));
      }

      if (undefined !== itemLink && itemLink.matches(this.itemMatches)) {
        return [...acc, itemLink];
      }

      return acc;
    }, []);

    /**
     * Initialize search.
     *
     * @type {Search}
     */
    this.search = new Search(this.menuBarItems);

    /**
     * The number of menubar items.
     *
     * @type {number}
     */
    this.menuLength = this.menuBarItems.length;

    /*
     * Set menubar link attributes.
     */
    this.menuBarItems.forEach((link, index) => {
      // Set the item's role.
      link.setAttribute('role', 'menuitem');

      // Add size and position attributes.
      link.setAttribute('aria-setsize', this.menuLength);
      link.setAttribute('aria-posinset', index + 1);

      // Set menubar item role.
      link.parentElement.setAttribute('role', 'presentation');

      link.parentElement.addEventListener('keydown', this.menubarHandleKeydown);
      link.addEventListener('click', this.menubarHandleClick);
    });

    // Collect first and last MenuBar items and merge them in as instance properties.
    const [firstItem, lastItem] = getFirstAndLastItems(this.menuBarItems);
    Object.assign(this, { firstItem, lastItem });

    /**
     * A mouse 'click' event.
     *
     * @type {MouseEvent}
     */
    this.clickEvent = new MouseEvent('click', {
      view: window,
      bubbles: true,
      cancelable: true,
    });

    // Initialize popups for nested lists.
    const { popups, subMenus } = this.menuBarItems.reduce((acc, controller) => {
      // Bail if there's no target attribute.
      if (! controller.hasAttribute('target')) {
        return acc;
      }

      const popup = new Popup_Popup(
        controller,
        {
          onInit: this.onPopupInit,
          type: 'menu',
        }
      );

      acc.popups.push(popup);

      const { target } = popup;

      // If target isn't a UL, find the UL in target and use it.
      const list = ('UL' === target.nodeName)
        ? target
        : target.querySelector('ul');

      // Bail if there's no list.
      if (null === list) {
        return acc;
      }

      // Initialize submenu Menus.
      const subMenu = new Menu_Menu(list, { itemMatches: this.itemMatches });
      target.addEventListener('keydown', this.menuItemHandleKeydown);

      // Save the list's previous sibling.
      subMenu.previousSibling = controller;
      acc.subMenus.push(subMenu);

      return acc;
    }, { popups: [], subMenus: [] });

    // Save components as instance properties.
    Object.assign(this, { popups, subMenus });

    /**
     * Set initial state.
     *
     * @type {object}
     */
    this.state = {
      menubarItem: this.firstItem,
      popup: this.constructor.getPopupFromMenubarItem(this.firstItem),
      expanded: false,
    };

    // Set up initial tabindex.
    rovingTabIndex(this.menuBarItems, this.firstItem);

    // Run {initCallback}
    this.onInit.call(this);
  }

  /**
   * Manage menubar state.
   *
   * @param {Object} state The component state.
   */
  stateWasUpdated() {
    const { menubarItem } = this.state;

    // Prevent tabbing to all but the currently-active menubar item.
    rovingTabIndex(this.menuBarItems, menubarItem);

    menubarItem.focus();

    // Run {stateChangeCallback}
    this.onStateChange.call(this, this.state);
  }

  /**
   * Handle keydown events on the menuList element.
   *
   * @param {Object} event The event object.
   */
  menubarHandleKeydown(event) {
    const {
      LEFT,
      RIGHT,
      DOWN,
      HOME,
      END,
      SPACE,
      RETURN,
    } = lib_keyCodes;
    const { keyCode } = event;
    const { menubarItem } = this.state;
    const popup = this.constructor.getPopupFromMenubarItem(menubarItem);

    switch (keyCode) {
      /*
       * Move through sibling list items.
       */
      case LEFT:
      case RIGHT: {
        const nextItem = nextPreviousFromLeftRight(
          keyCode,
          menubarItem,
          this.menuBarItems
        );

        if (nextItem) {
          event.stopPropagation();
          event.preventDefault();

          // Close the popup.
          if (popup) {
            popup.hide();
          }

          this.setState({
            menubarItem: nextItem,
          });
        }

        break;
      }

      /*
       * Open the popup if it exists and is not expanded.
       */
      case SPACE:
      case RETURN:
      case DOWN: {
        if (popup) {
          event.stopPropagation();
          event.preventDefault();

          if (! popup.state.expanded) {
            popup.show();
          }

          popup.firstInteractiveChild.focus();
        }

        break;
      }

      /*
       * Select the first MenuBar item.
       */
      case HOME: {
        event.preventDefault();
        const [firstItem] = this.menuBarItems;
        this.setState({
          menubarItem: firstItem,
        });

        break;
      }

      /*
       * Select the last MenuBar item.
       */
      case END: {
        event.preventDefault();
        this.setState({
          menubarItem: this.lastItem,
        });

        break;
      }

      /*
       * Select the MenuBar item based on a search string created by
       * collecting key presses.
       */
      default: {
        const itemToFocus = this.search.getItem(keyCode);
        if (null !== itemToFocus) {
          this.setState({ menubarItem: itemToFocus });
        }

        break;
      }
    }
  }

  /**
   * Update the active descendant when the item is clicked.
   *
   * @param {Object} event The event object.
   */
  menubarHandleClick(event) {
    this.setState({
      menubarItem: event.target,
    });
  }

  /**
   * Handle keydown events on sublist menuitems.
   *
   * @param {Object} event The event object.
   */
  menuItemHandleKeydown(event) {
    const { SPACE, RETURN } = lib_keyCodes;
    const { keyCode, target } = event;

    if ([SPACE, RETURN].includes(keyCode) && 'A' === target.nodeName) {
      event.stopPropagation();
      event.preventDefault();

      // Simulate a mouse event to activate the menuitem.
      target.dispatchEvent(this.clickEvent);
    }
  }

  /**
   * Recursively destroy MenuBar and Popups.
   */
  destroy() {
    // Remove the reference to the class instance.
    this.deleteSelfReferences();

    // Remove the menu role.
    this.list.removeAttribute('role');

    this.menuBarItems.forEach((link) => {
      // Remove list item role.
      link.parentElement.removeAttribute('role');

      // Remove size and position attributes.
      link.removeAttribute('aria-setsize');
      link.removeAttribute('aria-posinset');
      link.removeAttribute('role');

      // Remove event listeners.
      link.parentElement.removeEventListener(
        'keydown',
        this.menubarHandleKeydown
      );
      link.removeEventListener('click', this.menubarHandleClick);
    });

    // Remove tabindex attribute.
    tabIndexAllow(this.menuBarItems);

    // Destroy popups.
    this.popups.forEach((popup) => {
      popup.target.removeEventListener('keydown', this.menuItemHandleKeydown);

      popup.destroy();
    });

    // Destroy subMenus.
    this.subMenus.forEach((submenu) => {
      submenu.destroy();
    });

    // Run {destroyCallback}
    this.onDestroy.call(this);
  }
}

// CONCATENATED MODULE: ./src/Dialog/index.js







/**
 * Class to set up an interactive Dialog element.
 */
class Dialog_Dialog extends AriaComponent {
  /**
   * Create a Dialog.
   * @constructor
   *
   * @param {HTMLElement} controller The activating element.
   * @param {object}      options    The options object.
   */
  constructor(controller, options = {}) {
    super(controller);

    this.controller = controller;
    this.target = super.constructor.getTargetElement(controller);

    /**
     * The component name.
     *
     * @type {string}
     */
    this.componentName = 'Dialog';

    /**
     * Options shape.
     *
     * @type {object}
     */
    const defaultOptions = {
      /**
       * The element(s) to be hidden when the Dialog is visible. The elements
       * wrapping all site content with the sole exception of the dialog element.
       *
       * @type {HTMLElement|NodeList|Array}
       */
      content: [],

      /**
       * Callback to run after the component initializes.
       *
       * @callback initCallback
       */
      onInit: () => {},

      /**
       * Callback to run after component state is updated.
       *
       * @callback stateChangeCallback
       */
      onStateChange: () => {},

      /**
       * Callback to run after the component is destroyed.
       *
       * @callback destroyCallback
       */
      onDestroy: () => {},
    };

    // Merge remaining options with defaults and save all as instance properties.
    Object.assign(this, { ...defaultOptions, ...options });

    // Get the content items if none are provided.
    if (0 === this.content.length || undefined === this.content) {
      this.content = Array.from(document.body.children)
        .filter((child) => ! child.contains(this.target));
    } else {
      this.content = toArray(this.content);
    }

    // If no content is found.
    if (0 === this.content.length) {
      AriaComponent.configurationError(
        'The Dialog target should not be within the main site content'
      );
    }

    // Bind class methods
    this.onPopupStateChange = this.onPopupStateChange.bind(this);
    this.targetHandleKeydown = this.targetHandleKeydown.bind(this);
    this.handleKeydownEsc = this.handleKeydownEsc.bind(this);
    this.show = this.show.bind(this);
    this.hide = this.hide.bind(this);
    this.destroy = this.destroy.bind(this);
    this.stateWasUpdated = this.stateWasUpdated.bind(this);

    this.init();
  }

  /**
   * Set the component's DOM attributes and event listeners.
   */
  init() {
    /*
     * A reference to the class instance added to the controller and target
     * elements to enable external interactions with this instance.
     */
    super.setSelfReference([this.controller, this.target]);

    /**
     * The Popup instance controlling the Dialog.
     *
     * @type {Popup}
     */
    this.popup = new Popup_Popup(
      this.controller,
      {
        type: 'dialog',
        onStateChange: this.onPopupStateChange,
      }
    );

    // Allow focus on the target element.
    this.target.setAttribute('tabindex', '0');

    /*
     * Collect the Dialog's interactive child elements. This is an initial pass
     * to ensure values exists, but the interactive children will be collected
     * each time the dialog opens, in case the dialog's contents change.
     */
    this.interactiveChildElements = lib_interactiveChildren(this.target);

    // Add event listeners.
    this.target.addEventListener('keydown', this.targetHandleKeydown);

    /*
     * Remove clashing Popup event listener. This Popup event listener is
     * clashing with the Dialog's ability to trap keyboard tabs.
     */
    this.popup.target.removeEventListener(
      'keydown',
      this.popup.targetHandleKeydown
    );

    /**
     * Set initial state.
     *
     * @type {object}
     */
    this.state = { expanded: false };

    /* Run {initCallback} */
    this.onInit.call(this);
  }

  /**
   * Keep this component's state synced with the Popup's state.
   *
   * @param {Object} state The Popup state.
   */
  onPopupStateChange({ expanded }) {
    this.setState({ expanded });
  }

  /**
   * Update element attributes and event listeners when the Popup's state changes.
   *
   * @param {Object} state The component state.
   */
  stateWasUpdated() {
    const { expanded } = this.state;
    const contentLength = this.content.length;

    this.interactiveChildElements = lib_interactiveChildren(this.target);

    if (expanded) {
      for (let i = 0; i < contentLength; i += 1) {
        this.content[i].setAttribute('aria-hidden', 'true');
      }
      document.body.addEventListener('keydown', this.handleKeydownEsc);
      this.target.focus();
    } else {
      for (let i = 0; i < contentLength; i += 1) {
        this.content[i].setAttribute('aria-hidden', 'false');
      }
      document.body.removeEventListener('keydown', this.handleKeydownEsc);
      this.controller.focus();
    }

    /* Run {stateChangeCallback} */
    this.onStateChange.call(this, this.state);
  }

  /**
   * Close the dialog on when users click outside of the Dialog element.
   *
   * @param {Event} event The Event object.
   */
  outsideClick(event) {
    const { expanded } = this.state;

    if (expanded && ! this.target.contains(event.target)) {
      this.hide();
    }
  }

  /**
   * Trap key tabs within the dialog.
   *
   * @param {Event} event The Event object.
   */
  targetHandleKeydown(event) {
    const { TAB } = lib_keyCodes;
    const { keyCode, shiftKey } = event;
    const { expanded } = this.state;

    if (expanded && keyCode === TAB) {
      const { activeElement } = document;
      const [
        firstInteractiveChild,
        lastInteractiveChild,
      ] = getFirstAndLastItems(this.interactiveChildElements);

      if (shiftKey && firstInteractiveChild === activeElement) {
        event.preventDefault();
        /*
         * Move back from the first interactive child element to the last
         * interactive child element
         */
        lastInteractiveChild.focus();
      } else if (! shiftKey && lastInteractiveChild === activeElement) {
        event.preventDefault();
        /*
         * Move forward from the last interactive child element to the first
         * interactive child element.
         */
        firstInteractiveChild.focus();
      }
    }
  }

  /**
   * Close the dialog on ESC key press. This is added to the body element, so
   * any press of the ESC key will short-circuit the dialog and move forcus back
   * to the controller.
   *
   * @param {Event} event The Event object.
   */
  handleKeydownEsc(event) {
    const { ESC } = lib_keyCodes;
    const { keyCode } = event;

    if (ESC === keyCode) {
      this.hide();
    }
  }

  /**
   * Destroy the Dialog and Popup.
   */
  destroy() {
    // Remove the references to the class instance.
    this.deleteSelfReferences();

    // Destroy the Dialog Popup.
    this.popup.destroy();

    // Remove the `aria-hidden` attribute from the content wrapper.
    const contentLength = this.content.length;
    for (let i = 0; i < contentLength; i += 1) {
      this.content[i].removeAttribute('aria-hidden');
    }

    // Remove tabIndex attribute from target.
    this.target.removeAttribute('tabindex');

    // Remove event listeners.
    this.target.removeEventListener('keydown', this.targetHandleKeydown);
    document.body.removeEventListener('keydown', this.handleKeydownEsc);

    /* Run {destroyCallback} */
    this.onDestroy.call(this);
  }

  /**
   * Show the Dialog.
   */
  show() {
    this.popup.show();
  }

  /**
   * Hide the Dialog.
   */
  hide() {
    this.popup.hide();
  }
}

// CONCATENATED MODULE: ./src/Tablist/index.js







/**
 * Class for implimenting a tabs widget for sectioning content and displaying
 * one at a time.
 *
 * https://www.w3.org/TR/wai-aria-practices-1.1/#tabpanel
 * https://www.w3.org/TR/wai-aria-practices-1.1/examples/tabs/tabs-1/tabs.html
 */
class Tablist_Tablist extends AriaComponent {
  /**
   * Create a Tablist.
   * @constructor
   *
   * @param {object} options The options object.
   */
  constructor(tabs, options) {
    super(tabs);

    if ('UL' !== tabs.nodeName) {
      AriaComponent.configurationError(
        'The component element nodeName must be `UL`'
      );
    }

    this.tabs = tabs;

    /**
     * The component name.
     *
     * @type {string}
     */
    this.componentName = 'Tablist';

    /**
     * Component configuration options.
     *
     * @type {object}
     */
    const defaultOptions = {
      /**
       * Callback to run after the component initializes.
       *
       * @callback initCallback
       */
      onInit: () => {},

      /**
       * Callback to run after component state is updated.
       *
       * @callback stateChangeCallback
       */
      onStateChange: () => {},

      /**
       * Callback to run after the component is destroyed.
       *
       * @callback destroyCallback
       */
      onDestroy: () => {},
    };

    // Save references to the tablist and panels.
    Object.assign(this, { ...defaultOptions, ...options });

    // Intial component state.
    this.state = { activeIndex: 0 };

    // Bind class methods.
    this.panelHandleKeydown = this.panelHandleKeydown.bind(this);
    this.tabsHandleKeydown = this.tabsHandleKeydown.bind(this);
    this.tabsHandleClick = this.tabsHandleClick.bind(this);
    this.switchTo = this.switchTo.bind(this);
    this.destroy = this.destroy.bind(this);
    this.stateWasUpdated = this.stateWasUpdated.bind(this);

    /**
     * Collect the anchor inside of each list item. Using anchors makes
     * providing a non-JS fallback as simple as using the associated tabpanel's
     * ID attribute as the link's HREF.
     *
     * Required tab markup: `<li><a href=""></a></li>`
     *
     * @type {array}
     */
    this.tabLinks = Array.from(this.tabs.children)
      .filter((child) => null !== child.querySelector('a[href]'))
      .map((child) => child.querySelector('a[href]'));

    /**
     * Tablist panels.
     *
     * @type {array}
     */
    this.panels = this.tabLinks.reduce((acc, tabLink) => {
      const panel = document.getElementById(tabLink.hash.replace('#', ''));
      if (null !== panel) {
        return [...acc, panel];
      }

      return acc;
    }, []);

    // Only initialize if tabs and panels are equal in number.
    if (this.tabLinks.length === this.panels.length) {
      this.init();
    }
  }

  /**
   * Set up the component's DOM attributes and event listeners.
   */
  init() {
    // Component state is initially set in the constructor.
    const { activeIndex } = this.state;

    /*
     * The`tablist` role indicates that the list is a container for a set of tabs.
     *
     * https://www.w3.org/TR/wai-aria-1.1/#tablist
     */
    this.tabs.setAttribute('role', 'tablist');

    /*
     * Prevent the Tablist LI element from being announced as list-items as
     * that information is neither useful nor applicable.
     */
    Array.from(this.tabs.children).forEach((listChild) => {
      if ('LI' === listChild.nodeName) {
        listChild.setAttribute('role', 'presentation');
      }
    });

    // Set attributes for each tab.
    this.tabLinks.forEach((tab, index) => {
      /*
       * A reference to the class instance added to the controller and target
       * elements to enable external interactions with this instance.
       */
      super.setSelfReference([tab]);

      // Ensure each tab has an ID.
      setUniqueId(tab);
      // Add the `tab` role to indicate its relationship to the Tablist.
      tab.setAttribute('role', 'tab');

      if (activeIndex !== index) {
        // Don't allow focus on inactive tabs.
        tab.setAttribute('tabindex', '-1');
      } else {
        // Set the first tab as selected by default.
        tab.setAttribute('aria-selected', 'true');
      }

      tab.setAttribute('aria-controls', this.panels[index].id);
    });

    // Add event listeners.
    this.tabs.addEventListener('click', this.tabsHandleClick);
    this.tabs.addEventListener('keydown', this.tabsHandleKeydown);

    // Set attributes or each panel.
    this.panels.forEach((panel, index) => {
      /*
       * Add a reference to the class instance to enable external interactions
       * with this instance.
       */
      super.setSelfReference([panel]);

      // Ensure each panel has an ID.
      setUniqueId(panel);
      // Add the `tabpanel` role to indicate its relationship to the tablist.
      panel.setAttribute('role', 'tabpanel');
      // Create a relationship between the tab and its panel.
      panel.setAttribute('aria-labelledby', this.tabLinks[index].id);
      // All but the first tab should be hidden by default.
      if (activeIndex === index) {
        panel.setAttribute('tabindex', '0');
        panel.setAttribute('aria-hidden', 'false');
        panel.removeAttribute('hidden');
      } else {
        panel.setAttribute('aria-hidden', 'true');
        panel.setAttribute('hidden', '');
      }

      // Listen for panel keydown events.
      panel.addEventListener('keydown', this.panelHandleKeydown);
    });

    // Save the active panel's interactive children.
    this.interactiveChildElements = lib_interactiveChildren(this.panels[activeIndex]); // eslint-disable-line max-len

    // Run {initCallback}
    this.onInit.call(this);
  }

  /**
   * Update tab and panel attributes based on component state.
   *
   * @param {object} state The component state.
   * @param {number} state.activeIndex The active index of both tabs and panels.
   */
  stateWasUpdated() {
    const { activeIndex } = this.state;

    // Get the tab currently designated as `aria-selected`.
    const [deactivate] = this.tabLinks.filter((tab) => (
      'true' === tab.getAttribute('aria-selected')
    ));
    // Get the index; this is essentially the previous `activeIndex` state.
    const deactiveIndex = this.tabLinks.indexOf(deactivate);

    // Deactivate the previously-selected tab.
    deactivate.setAttribute('tabindex', '-1');
    deactivate.removeAttribute('aria-selected');
    this.panels[deactiveIndex].setAttribute('aria-hidden', 'true');
    this.panels[deactiveIndex].setAttribute('hidden', '');
    this.panels[deactiveIndex].removeAttribute('tabindex');

    // Prevent tabbing to interactive children of the deactivated panel.
    const deactiveChildren = lib_interactiveChildren(this.panels[deactiveIndex]);
    tabIndexDeny(deactiveChildren);

    // Actvate the newly active tab.
    this.tabLinks[activeIndex].removeAttribute('tabindex');
    this.tabLinks[activeIndex].setAttribute('aria-selected', 'true');
    this.panels[activeIndex].setAttribute('aria-hidden', 'false');
    this.panels[activeIndex].removeAttribute('hidden');
    this.panels[activeIndex].setAttribute('tabindex', '0');

    // Allow tabbing to the newly-active panel.
    this.interactiveChildElements = lib_interactiveChildren(this.panels[activeIndex]); // eslint-disable-line max-len
    tabIndexAllow(this.interactiveChildElements);

    // Run {stateChangeCallback}
    this.onStateChange.call(this, this.state);
  }

  /**
   * Handle keydown events on the tabpanels.
   *
   * @param {Event} event The event object.
   */
  panelHandleKeydown(event) {
    const { TAB } = lib_keyCodes;
    const { activeIndex } = this.state;
    const { keyCode, shiftKey } = event;
    const { activeElement } = document;
    const [firstInteractiveChild] = this.interactiveChildElements;

    if (keyCode === TAB && shiftKey) {
      if (activeElement === this.panels[activeIndex]) {
        event.preventDefault();
        this.tabLinks[activeIndex].focus();
      } else if (activeElement === firstInteractiveChild) {
        /*
         * Ensure navigating with Shift-TAB from the first interactive child of
         * the active panel returns focus to the active panel.
         */
        event.preventDefault();
        this.panels[activeIndex].focus();
      }
    }
  }

  /**
   * Handle tablist key presses.
   *
   * @param {Event} event The event object.
   */
  tabsHandleKeydown(event) {
    const {
      TAB,
      LEFT,
      RIGHT,
      DOWN,
      HOME,
      END,
    } = lib_keyCodes;
    const { keyCode, shiftKey, target } = event;
    const currentIndex = this.tabLinks.indexOf(target);

    switch (keyCode) {
      /*
       * Move focus from the active tab to the active panel.
       */
      case TAB: {
        if (! shiftKey) {
          event.preventDefault();

          this.panels[currentIndex].focus();
        }

        break;
      }

      /*
       * Move to and activate the previous or next tab.
       */
      case LEFT:
      case RIGHT: {
        const newItem = nextPreviousFromLeftRight(
          keyCode,
          target,
          this.tabLinks
        );

        if (newItem) {
          event.preventDefault();

          this.switchTo(this.tabLinks.indexOf(newItem));
          newItem.focus();
        }

        break;
      }

      /*
       * Focus the active panel itself with the down arrow.
       */
      case DOWN: {
        event.preventDefault();

        this.panels[currentIndex].setAttribute('tabindex', '0');
        this.panels[currentIndex].focus();

        break;
      }

      /*
       * Select the first Tablist tab.
       */
      case HOME: {
        event.preventDefault();
        this.switchTo(0);
        this.tabLinks[0].focus();

        break;
      }

      /*
       * Select the last Tablist tab.
       */
      case END: {
        event.preventDefault();
        const lastIndex = this.tabLinks.length - 1;
        this.switchTo(lastIndex);
        this.tabLinks[lastIndex].focus();

        break;
      }

      // fuggitaboutit.
      default:
        break;
    }
  }

  /**
   * Activate the tab panel when a tab is clicked.
   *
   * @param {Event} event The event object.
   */
  tabsHandleClick(event) {
    const { target } = event;
    event.preventDefault();

    // Don't act when an active tab is clicked.
    if ('true' !== target.getAttribute('aria-selected')) {
      if (this.tabLinks.includes(target)) {
        this.switchTo(this.tabLinks.indexOf(target));
      }
    }
  }

  /**
   * Switch directly to a tab.
   *
   * @param {number} index The zero-based tab index to activate.
   */
  switchTo(index) {
    this.setState({ activeIndex: index });
  }

  /**
   * Destroy the tablist, removing ARIA attributes and event listeners
   */
  destroy() {
    // Remove the tablist role.
    this.tabs.removeAttribute('role');

    // Remove the 'presentation' role from each list item.
    Array.from(this.tabs.children).forEach((listChild) => {
      if ('LI' === listChild.nodeName) {
        listChild.removeAttribute('role');
      }
    });

    // Remove the references to the class instance.
    this.deleteSelfReferences();

    // Remove tab attributes and event listeners.
    this.tabLinks.forEach((tab) => {
      tab.removeAttribute('role');
      tab.removeAttribute('aria-selected');
      tab.removeAttribute('tabindex');
      tab.removeAttribute('aria-controls');

      tab.removeEventListener('click', this.tabsHandleClick);
      tab.removeEventListener('keydown', this.tabsHandleKeydown);
    });

    // Remove panel attributes and event listeners.
    this.panels.forEach((panel) => {
      panel.removeAttribute('role');
      panel.removeAttribute('aria-hidden');
      panel.removeAttribute('hidden');
      panel.removeAttribute('tabindex');
      panel.removeAttribute('aria-labelledby');

      // Make sure to allow tabbing to all children of all panels.
      const interactiveChildElements = lib_interactiveChildren(panel);
      tabIndexAllow(interactiveChildElements);

      panel.removeEventListener(
        'keydown',
        this.panelHandleKeydown
      );
    });

    // Run {destroyCallback}
    this.onDestroy.call(this);
  }
}

// CONCATENATED MODULE: ./src/MenuButton/index.js





/**
 * Class to set up an interactive Menu Button element.
 *
 * https://www.w3.org/TR/wai-aria-practices-1.1/#menubutton
 * https://www.w3.org/TR/wai-aria-practices-1.1/examples/menu-button/menu-button-links.html
 */
class MenuButton_MenuButton extends AriaComponent {
  /**
   * Create a ListBox.
   * @constructor
   *
   * @param {HTMLElement} controller The activating element.
   * @param {object}      options    The options object.
   */
  constructor(controller, options = {}) {
    super(controller);

    this.controller = controller;
    this.target = super.constructor.getTargetElement(controller);

    /**
     * The component name.
     *
     * @type {string}
     */
    this.componentName = 'MenuButton';

    /**
     * Options shape.
     *
     * @type {object}
     */
    const defaultOptions = {
      /**
       * The Menu element.
       *
       * @type {HTMLUListElement}
       */
      list: null,

      /**
       * Callback to run after the component initializes.
       *
       * @callback initCallback
       */
      onInit: () => {},

      /**
       * Callback to run after component state is updated.
       *
       * @callback stateChangeCallback
       */
      onStateChange: () => {},

      /**
       * Callback to run after the component is destroyed.
       *
       * @callback destroyCallback
       */
      onDestroy: () => {},
    };

    // Merge options with defaults.
    Object.assign(this, { ...defaultOptions, ...options });

    // Bind class methods.
    this.controllerHandleKeydown = this.controllerHandleKeydown.bind(this);
    this.onPopupStateChange = this.onPopupStateChange.bind(this);
    this.show = this.show.bind(this);
    this.hide = this.hide.bind(this);
    this.destroy = this.destroy.bind(this);

    this.init();
  }

  /**
   * Set up the component's DOM attributes and event listeners.
   */
  init() {
    /**
     * The MenuButton is basically a Popup to present a Menu, so we instantiate
     * a Popup and subscribe to state changes to act on the MenuButton when the
     * Popup is shown and hidden.
     *
     * @type {Popup}
     */
    this.popup = new Popup_Popup(
      this.controller,
      {
        type: 'menu',
        onStateChange: this.onPopupStateChange,
      }
    );

    // Initialize the Menu if we passed one in.
    if (null != this.list && 'UL' === this.list.nodeName) {
      this.menu = new Menu_Menu(this.list);
    } else if ('UL' === this.target.nodeName) {
      // Fallback to the target if it's a UL.
      this.menu = new Menu_Menu(this.target);
    } else {
      const list = this.target.querySelector('ul');
      this.menu = new Menu_Menu(list);
    }

    // Additional event listener(s).
    this.controller.addEventListener('keydown', this.controllerHandleKeydown);

    /**
     * Set initial state.
     *
     * @type {object}
     */
    this.state = { expanded: false };

    // Run {initCallback}
    this.onInit.call(this);
  }

  /**
   * Keep this component's state synced with the Popup's state.
   *
   * @param {Object} state The Popup state.
   */
  onPopupStateChange(state) {
    this.setState(state);

    // Run {stateChangeCallback}
    this.onStateChange.call(this, this.state);
  }

  /**
   * Handle keydown events on the MenuButton controller.
   *
   * @param {Event} event The event object.
   */
  controllerHandleKeydown(event) {
    const { keyCode } = event;
    const {
      RETURN,
      UP,
      DOWN,
      SPACE,
    } = lib_keyCodes;

    switch (keyCode) {
      /*
       * Open the menu and move focus to the first menu item.
       */
      case RETURN:
      case SPACE:
      case DOWN: {
        event.preventDefault();
        this.show();

        // Move focus to the first menu item.
        if (this.menu.firstItem) {
          this.menu.firstItem.focus();
        }

        break;
      }

      /*
       * Opens the menu and move focus to the last menu item.
       */
      case UP: {
        event.preventDefault();
        this.show();

        // Move focus to the last menu item.
        if (this.menu.lastItem) {
          this.menu.lastItem.focus();
        }

        break;
      }

      default:
        break;
    }
  }

  /**
   * Destroy the Popup and Menu.
   */
  destroy() {
    // Destroy the MenuButton Popup.
    this.popup.destroy();

    // Destroy the Menu.
    this.menu.destroy();

    // Remove event listener.
    this.controller.removeEventListener(
      'keydown',
      this.controllerHandleKeydown
    );

    // Run {destroyCallback}
    this.onDestroy.call(this);
  }

  /**
   * Show the menu Popup.
   */
  show() {
    this.popup.show();
  }

  /**
   * Hide the menu Popup.
   */
  hide() {
    this.popup.hide();
  }
}

// CONCATENATED MODULE: ./index.js












// EXTERNAL MODULE: ./docs/_client/src/components/popup/popup.scss
var popup_popup = __webpack_require__(2);

// CONCATENATED MODULE: ./docs/_client/src/components/popup/index.js
/* eslint-disable no-unused-vars */


 // Get the components hashed classnames.

var _getClassnames = getClassnames(siteClassNames.popup),
    popup_button = _getClassnames.button; // Get the elements.


var popup_controller = document.querySelector(popup_button); // Create the Popup.

var components_popup_popup = new Popup_Popup(popup_controller);
// EXTERNAL MODULE: ./docs/_client/src/components/tablist/tablist.scss
var tablist = __webpack_require__(3);

// CONCATENATED MODULE: ./docs/_client/src/components/tablist/index.js
/* eslint-disable no-unused-vars */


 // Get the components hashed classnames.

var tablist_getClassnames = getClassnames(siteClassNames.tablist),
    tablist_list = tablist_getClassnames.list; // Get the elements.


var tablist_tabs = document.querySelector(tablist_list); // Create the Tablist.

var tablist_tablist = new Tablist_Tablist(tablist_tabs);
window.addEventListener('load', tablistHashCheck);
window.addEventListener('hashchange', tablistHashCheck);
/**
 * Check for a hash in the URL and activate the corresponding tab.
 */

function tablistHashCheck() {
  var hash = window.location.hash.replace('#', '');
  var el = document.getElementById(hash);

  if (null !== el && el.tablist instanceof Tablist_Tablist) {
    var index = tablist_tablist.panels.indexOf(el);

    if (-1 < index) {
      tablist_tablist.switchTo(index);
      el.scrollIntoView({
        behavior: 'smooth'
      });
    }
  }
}
// EXTERNAL MODULE: ./docs/_client/src/components/listbox/listbox.scss
var listbox = __webpack_require__(4);

// CONCATENATED MODULE: ./docs/_client/src/components/listbox/index.js
/* eslint-disable no-unused-vars */


 // Get the components hashed classnames.

var listbox_getClassnames = getClassnames(siteClassNames.listbox),
    listbox_button = listbox_getClassnames.button; // Get the elements.


var listbox_controller = document.querySelector(listbox_button); // Create the Listbox.

var listbox_listbox = new Listbox_ListBox(listbox_controller);
// EXTERNAL MODULE: ./docs/_client/src/components/menu/menu.scss
var menu_menu = __webpack_require__(5);

// CONCATENATED MODULE: ./docs/_client/src/components/menu/index.js
/* eslint-disable no-unused-vars */


 // Get the components hashed classnames.

var menu_getClassnames = getClassnames(siteClassNames.menu),
    menu_list = menu_getClassnames.list; // Get the elements.


var menuList = document.querySelector(menu_list); // Create the Menu.
// Alteratively pass `collapse: true` to collapse submenus as Disclosures.

var components_menu_menu = new Menu_Menu(menuList);
// EXTERNAL MODULE: ./docs/_client/src/components/dialog/dialog.scss
var dialog_dialog = __webpack_require__(6);

// CONCATENATED MODULE: ./docs/_client/src/components/dialog/index.js


 // Get the components hashed classnames.

var dialog_getClassnames = getClassnames(siteClassNames.dialog),
    dialog_link = dialog_getClassnames.link,
    closeButton = dialog_getClassnames.closeButton;

window.addEventListener('load', function () {
  // Get the elements.
  var controller = document.querySelector(dialog_link);
  var close = document.querySelector(closeButton); // Create the Dialog.

  var dialog = new Dialog_Dialog(controller);
  close.addEventListener('click', dialog.hide);
});
// EXTERNAL MODULE: ./docs/_client/src/components/menubar/menubar.scss
var menubar = __webpack_require__(7);

// CONCATENATED MODULE: ./docs/_client/src/components/menubar/index.js
/* eslint-disable no-unused-vars */


 // Get the components hashed classnames.

var menubar_getClassnames = getClassnames(siteClassNames.menubar),
    menubar_list = menubar_getClassnames.list; // Get the elements.


var menuBarList = document.querySelector(menubar_list); // Create the MenuBar.

var menuBar = new MenuBar_MenuBar(menuBarList);
// EXTERNAL MODULE: ./docs/_client/src/components/disclosure/disclosure.scss
var disclosure_disclosure = __webpack_require__(8);

// CONCATENATED MODULE: ./docs/_client/src/components/disclosure/index.js
/* eslint-disable no-unused-vars */


 // Get the components hashed classnames.

var disclosure_getClassnames = getClassnames(siteClassNames.disclosure),
    disclosure_button = disclosure_getClassnames.button,
    info = disclosure_getClassnames.info; // Get the elements.


var controllers = document.querySelectorAll(disclosure_button); // Create the Disclosures.

var disclosures = Array.from(controllers).map(function (controller, index) {
  return new Disclosure_Disclosure(controller);
});
window.addEventListener('load', disclosureHashCheck);
window.addEventListener('hashchange', disclosureHashCheck);
/**
 * Check for a hash in the URL and open the corresponding disclosure.
 */

function disclosureHashCheck() {
  var hash = window.location.hash.replace('#', '');
  var el = document.getElementById(hash);

  if (null !== el && el.disclosure instanceof Disclosure_Disclosure) {
    var disclosure = el.disclosure;
    disclosure.open();
    disclosure.controller.scrollIntoView({
      behavior: 'smooth'
    });
  }
}
// EXTERNAL MODULE: ./docs/_client/src/components/menubutton/menubutton.scss
var menubutton = __webpack_require__(9);

// CONCATENATED MODULE: ./docs/_client/src/components/menubutton/index.js
/* eslint-disable no-unused-vars */


 // Get the components hashed classnames.

var menubutton_getClassnames = getClassnames(siteClassNames.menubutton),
    menubutton_button = menubutton_getClassnames.button; // Get the elements.


var menubutton_controller = document.querySelector(menubutton_button); // Create the MenuButton.

var menuButton = new MenuButton_MenuButton(menubutton_controller);
// CONCATENATED MODULE: ./docs/_client/entries/index.js
// Global Styles

 // Components.










/***/ })
/******/ ]);
//# sourceMappingURL=global.7160a46a21995186cdb5.bundle.min.js.map