{"version":3,"file":"js/global.7160a46a21995186cdb5.bundle.min.js","sources":["webpack:///webpack/bootstrap","webpack:///./docs/_client/src/scss/reset.scss","webpack:///./docs/_client/src/scss/index.scss","webpack:///./docs/_client/src/components/popup/popup.scss","webpack:///./docs/_client/src/components/tablist/tablist.scss","webpack:///./docs/_client/src/components/listbox/listbox.scss","webpack:///./docs/_client/src/components/menu/menu.scss","webpack:///./docs/_client/src/components/dialog/dialog.scss","webpack:///./docs/_client/src/components/menubar/menubar.scss","webpack:///./docs/_client/src/components/disclosure/disclosure.scss","webpack:///./docs/_client/src/components/menubutton/menubutton.scss","webpack:///./docs/_client/src/js/getClassnames.js","webpack:///./src/AriaComponent.js","webpack:///./src/lib/keyCodes.js","webpack:///./src/lib/interactiveChildren.js","webpack:///./src/lib/toArray.js","webpack:///./src/lib/rovingTabIndex.js","webpack:///./src/lib/uniqueId.js","webpack:///./src/lib/getFirstAndLastItems.js","webpack:///./src/Popup/index.js","webpack:///./src/lib/Search.js","webpack:///./src/Listbox/index.js","webpack:///./src/Disclosure/index.js","webpack:///./src/lib/isInstanceOf.js","webpack:///./src/lib/nextPrevious.js","webpack:///./src/Menu/index.js","webpack:///./src/MenuBar/index.js","webpack:///./src/Dialog/index.js","webpack:///./src/Tablist/index.js","webpack:///./src/MenuButton/index.js","webpack:///./index.js","webpack:///./docs/_client/src/components/popup/index.js","webpack:///./docs/_client/src/components/tablist/index.js","webpack:///./docs/_client/src/components/listbox/index.js","webpack:///./docs/_client/src/components/menu/index.js","webpack:///./docs/_client/src/components/dialog/index.js","webpack:///./docs/_client/src/components/menubar/index.js","webpack:///./docs/_client/src/components/disclosure/index.js","webpack:///./docs/_client/src/components/menubutton/index.js","webpack:///./docs/_client/entries/index.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/build/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","/**\n * Formats classnames from a given namespace\n * Essentially just adds a '.' to the beginning of classnames\n *\n * @param {Object} namespace The namespace within which to format classnames.\n * @return {Object}\n */\nexport default function getClassnames(namespace) {\n  return Object.keys(namespace).reduce(function (acc, key) {\n    acc[key] = \".\".concat(namespace[key]);\n    return acc;\n  }, {});\n}","/**\n * Class for facilitating accessible components.\n */\nexport default class AriaComponent {\n  /**\n   * Get the target element based on the controller's target attribute.\n   *\n   * @param  {HTMLElement} controller The components controlling element.\n   * @return {HTMLElement|null}\n   */\n  static getTargetElement(controller) {\n    if (! controller.hasAttribute('target')) {\n      AriaComponent.configurationError(\n        'The component element is missing the required \\'target\\' attribute'\n      );\n    }\n\n    const targetId = controller.getAttribute('target');\n    const target = document.getElementById(targetId);\n\n    if (null === target) {\n      AriaComponent.configurationError(\n        `A target element with ID of '${targetId}' is not found`\n      );\n    }\n\n    return target;\n  }\n\n  /**\n   * Throw a confguration error.\n   *\n   * @param {string} message The error message.\n   */\n  static configurationError(message) {\n    throw new Error(`Configuration error: ${message}`);\n  }\n\n  /**\n   * Create an AriaComponent.\n   * @constructor\n   */\n  constructor(element) {\n    // Validate the component element.\n    if (false === Boolean(element) || ! (element instanceof HTMLElement)) {\n      AriaComponent.configurationError(\n        'The component element must be a valid HTMLElement'\n      );\n    }\n\n    /**\n     * Component state.\n     *\n     * @type {object}\n     */\n    this.state = {};\n\n    /**\n     * Save search characters\n     *\n     * @type {string}\n     */\n    this.searchString = '';\n\n    /**\n     * Saved reference elements.\n     *\n     * @type {Array}\n     */\n    this.referenceElements = [];\n\n    // Bind class methods.\n    this.setState = this.setState.bind(this);\n    this.getState = this.getState.bind(this);\n    this.setSelfReference = this.setSelfReference.bind(this);\n  }\n\n  /**\n   * Set component state.\n   *\n   * @param {object} newState The new state to merge with existing state.\n   */\n  setState(newState) {\n    Object.assign(this.state, newState);\n\n    if ('function' === typeof this.stateWasUpdated) {\n      this.stateWasUpdated();\n    }\n  }\n\n  /**\n   * Set a reference to the class instance on the element upon which the class\n   * is instantiated.\n   *\n   * @param {array} elements An array of elements upon which to add a reference to `this`.\n   */\n  setSelfReference(elements) {\n    const referenceElements = [...elements].map((element) => {\n      Object.defineProperty(\n        element,\n        this.componentName.toLowerCase(),\n        { value: this, configurable: true }\n      );\n\n      return element;\n    });\n\n    this.referenceElements = [...this.referenceElements, ...referenceElements];\n  }\n\n  /**\n   * Delete self references from component elements.\n   */\n  deleteSelfReferences() {\n    this.referenceElements.forEach((element) => {\n      delete element[this.componentName.toLowerCase()];\n    });\n  }\n\n  /**\n   * Return the current component state.\n   *\n   * @return {object}\n   */\n  getState() {\n    return this.state;\n  }\n}\n","/**\n * Event keyCode values mapped to a key name.\n */\nconst keyCodes = Object.freeze({\n  TAB: 9,\n  RETURN: 13,\n  ESC: 27,\n  SPACE: 32,\n  END: 35,\n  HOME: 36,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n});\n\nexport default keyCodes;\n","/**\n * Collect all interactive child elements.\n *\n * @param {HTMLElement} target The element in which to search for interactive children.\n *\n * @return {Array}\n */\nfunction interactiveChildren(target) {\n  // List of possible active child element selectors\n  const selectors = [\n    'a[href]',\n    'area[href]',\n    'input:not([disabled])',\n    'select:not([disabled])',\n    'textarea:not([disabled])',\n    'button:not([disabled])',\n    'iframe',\n    'object',\n    'embed',\n    '[contenteditable]',\n    '[tabindex]:not([tabindex^=\"-\"])',\n  ].join(',');\n\n  const interactiveElements = target.querySelectorAll(selectors);\n\n  return Array.from(interactiveElements);\n}\n\nexport default interactiveChildren;\n","/**\n * Create an array from a value.\n *\n * @param {Mixed} maybeAnArray An HTMLElement, NodeList, or Array of elements.\n */\nexport default function toArray(maybeAnArray) {\n  if (Array.isArray(maybeAnArray)) {\n    return maybeAnArray;\n  }\n\n  let shouldBeAnArray = [];\n\n  if (maybeAnArray instanceof HTMLElement) {\n    // Convert a single element to an Array.\n    shouldBeAnArray = new Array(maybeAnArray);\n  } else if (\n    maybeAnArray instanceof NodeList\n    || maybeAnArray instanceof HTMLCollection\n  ) {\n    shouldBeAnArray = Array.from(maybeAnArray);\n  }\n\n  return shouldBeAnArray;\n}\n","import toArray from './toArray';\n\n/**\n * Remove the tabIndex attribute from all elements.\n *\n * @param {Mixed} items An HTMLElement, NodeList, or array of elements.\n */\nfunction tabIndexAllow(items) {\n  const allowedElements = toArray(items);\n\n  allowedElements.forEach((item) => {\n    item.removeAttribute('tabindex');\n  });\n}\n\n/**\n * Add a negative tabIndex attribute to all elements.\n *\n * @param {Mixed} items An HTMLElement, NodeList, or Array of elements.\n */\nfunction tabIndexDeny(items) {\n  const deniedElements = toArray(items);\n\n  deniedElements.forEach((item) => {\n    item.setAttribute('tabindex', '-1');\n  });\n}\n\n/**\n * Manage items' tabindex.\n *\n * @param {NodeList|Array}             items The items whose tabindex may need updating.\n * @param {HTMLElement|NodeList|Array} allow The item to which we'll allow tabbing.\n */\nfunction rovingTabIndex(items, allow) {\n  const allowedElements = toArray(allow);\n  const allItems = toArray(items);\n\n  tabIndexAllow(allowedElements);\n\n  if (0 < allItems.length) {\n    const deniedElements = allItems.filter((item) => (\n      ! allowedElements.includes(item)\n    ));\n    tabIndexDeny(deniedElements);\n  }\n}\n\nexport {\n  rovingTabIndex,\n  tabIndexAllow,\n  tabIndexDeny,\n};\n","/**\n * Create a passably unique `id` attribute.\n *\n * @param {Number} radix An optional base for converting the Number to a String.\n *\n * @returns {String}\n */\nfunction getUniqueId(radix = 36) {\n  const [, attr] = Math.random().toString(radix).split('.');\n  return `id_${attr}`;\n}\n\n/**\n * Set the ID attribute if the element does not already have one.\n *\n * @param {HTMLElement} element the element upon which to act.\n */\nfunction setUniqueId(element) {\n  if (null !== element && '' === element.id) {\n    element.setAttribute('id', getUniqueId());\n  }\n}\n\nexport {\n  getUniqueId,\n  setUniqueId,\n};\n","import toArray from './toArray';\n\n/**\n * Get the first and last items from and Array or NodeList.\n *\n * @param  {array|NodeList} items The Array or NodeList from which to retrieve the items.\n * @return {array}                The first and last items.\n */\nexport default function getFirstAndLastItems(items) {\n  // Ensure we're working with an Array;\n  const arrayOfItems = toArray(items);\n  const lastIndex = (arrayOfItems.length - 1);\n\n  // Get the first and last items by index.\n  const {\n    0: firstItem,\n    [lastIndex]: lastItem,\n  } = arrayOfItems;\n\n  return [firstItem, lastItem];\n}\n","import AriaComponent from '../AriaComponent';\nimport keyCodes from '../lib/keyCodes';\nimport interactiveChildren from '../lib/interactiveChildren';\nimport { tabIndexDeny, tabIndexAllow } from '../lib/rovingTabIndex';\nimport { setUniqueId } from '../lib/uniqueId';\nimport getFirstAndLastItems from '../lib/getFirstAndLastItems';\n\n/**\n * Class for setting up an interactive popup element that can be triggered by a\n * controlling element.\n */\nexport default class Popup extends AriaComponent {\n  /**\n   * Create a MenuBar.\n   * @constructor\n   *\n   * @param {HTMLElement} controller The activating element.\n   * @param {object}      options    The options object.\n   */\n  constructor(controller, options = {}) {\n    super(controller);\n\n    this.controller = controller;\n    this.target = super.constructor.getTargetElement(controller);\n\n    /**\n     * The component name.\n     *\n     * @type {string}\n     */\n    this.componentName = 'Popup';\n\n    /**\n     * Component configuration options.\n     *\n     * @type {object}\n     */\n    const defaultOptions = {\n      /**\n       * The value of `aria-haspopup` must match the role of the Popup container.\n       * Options: menu, listbox, tree, grid, or dialog,\n       *\n       * @type {string}\n       */\n      type: 'true', // 'true' === 'menu' in UAs that don't support WAI-ARIA 1.1\n\n      /**\n       * Callback to run after the component initializes.\n       *\n       * @callback initCallback\n       */\n      onInit: () => {},\n\n      /**\n       * Callback to run after component state is updated.\n       *\n       * @callback stateChangeCallback\n       */\n      onStateChange: () => {},\n\n      /**\n       * Callback to run after the component is destroyed.\n       *\n       * @callback destroyCallback\n       */\n      onDestroy: () => {},\n    };\n\n    // Save references to the controller and target.\n    Object.assign(this, { ...defaultOptions, ...options });\n\n    // Intial component state.\n    this.state = { expanded: false };\n\n    // Bind class methods.\n    this.init = this.init.bind(this);\n    this.stateWasUpdated = this.stateWasUpdated.bind(this);\n    this.hide = this.hide.bind(this);\n    this.show = this.show.bind(this);\n    this.controllerHandleClick = this.controllerHandleClick.bind(this);\n    this.controllerHandleKeydown = this.controllerHandleKeydown.bind(this);\n    this.targetHandleKeydown = this.targetHandleKeydown.bind(this);\n    this.hideOnTabOut = this.hideOnTabOut.bind(this);\n    this.hideOnOutsideClick = this.hideOnOutsideClick.bind(this);\n    this.destroy = this.destroy.bind(this);\n\n    this.init();\n  }\n\n  /**\n   * Set up the component's DOM attributes and event listeners.\n   */\n  init() {\n    /*\n     * A reference to the class instance added to the controller and target\n     * elements to enable external interactions with this instance.\n     */\n    super.setSelfReference([this.controller, this.target]);\n\n    /**\n     * Collect the target element's interactive child elements.\n     *\n     * @type {array}\n     */\n    this.interactiveChildElements = interactiveChildren(this.target);\n\n    // Focusable content should initially have tabindex='-1'.\n    tabIndexDeny(this.interactiveChildElements);\n\n    /*\n     * Collect first and last interactive child elements from target and merge\n     * them in as instance properties.\n     */\n    if (0 < this.interactiveChildElements.length) {\n      const [\n        firstInteractiveChild,\n        lastInteractiveChild,\n      ] = getFirstAndLastItems(this.interactiveChildElements);\n\n      Object.assign(this, { firstInteractiveChild, lastInteractiveChild });\n    }\n\n    // Add target attribute.\n    setUniqueId(this.target);\n\n    // Add controller attributes\n    this.controller.setAttribute('aria-haspopup', this.type);\n    this.controller.setAttribute('aria-expanded', 'false');\n    this.controller.setAttribute('aria-controls', this.target.id);\n    setUniqueId(this.controller);\n\n    /**\n     * Check if the controller is a button, but only if it doesn't already have\n     * a role attribute, since we'll be adding the role and allowing focus.\n     *\n     * @type {bool}\n     */\n    this.controllerIsNotAButton = (\n      'BUTTON' !== this.controller.nodeName\n      && null === this.controller.getAttribute('role')\n    );\n\n    /*\n     * Use the button role on non-button elements.\n     */\n    if (this.controllerIsNotAButton) {\n      // https://www.w3.org/TR/wai-aria-1.1/#button\n      this.controller.setAttribute('role', 'button');\n      this.controller.setAttribute('tabindex', '0');\n    }\n\n    /*\n     * Establishes a relationship when the DOM heirarchy doesn't represent that\n     * a relationship exists.\n     */\n    if (this.target !== this.controller.nextElementSibling) {\n      this.controller.setAttribute('aria-owns', this.target.id);\n    }\n\n    /*\n     * Set the taget as hidden by default. Using the `aria-hidden` attribute,\n     * rather than the `hidden` attribute, means authors must hide the target\n     * element via CSS.\n     */\n    this.target.setAttribute('aria-hidden', 'true');\n    this.target.setAttribute('hidden', '');\n\n    // Add event listeners\n    this.controller.addEventListener('click', this.controllerHandleClick);\n    this.controller.addEventListener('keydown', this.controllerHandleKeydown);\n    this.target.addEventListener('keydown', this.targetHandleKeydown);\n    document.body.addEventListener('click', this.hideOnOutsideClick);\n\n    // Run {initCallback}\n    this.onInit.call(this);\n  }\n\n  /**\n   * Update the component attributes based on updated state.\n   *\n   * @param {object} state The component state.\n   */\n  stateWasUpdated() {\n    const { expanded } = this.state;\n\n    this.controller.setAttribute('aria-expanded', `${expanded}`);\n\n    /*\n     * Update Popup and interactive children's attributes.\n     */\n    if (expanded) {\n      this.target.setAttribute('aria-hidden', 'false');\n      this.target.removeAttribute('hidden');\n\n      tabIndexAllow(this.interactiveChildElements);\n    } else {\n      this.target.setAttribute('aria-hidden', 'true');\n      this.target.setAttribute('hidden', '');\n\n      // Focusable content should have tabindex='-1' or be removed from the DOM.\n      tabIndexDeny(this.interactiveChildElements);\n    }\n\n    // Run {stateChangeCallback}\n    this.onStateChange.call(this, this.state);\n  }\n\n  /**\n   * Handle keydown events on the Popup controller.\n   *\n   * @param {Event} event The event object.\n   */\n  controllerHandleKeydown(event) {\n    const { expanded } = this.state;\n    const {\n      ESC,\n      TAB,\n      SPACE,\n      RETURN,\n    } = keyCodes;\n    const { keyCode } = event;\n\n    if ([SPACE, RETURN].includes(keyCode)) {\n      /*\n       * Treat the Spacebar and Return keys as clicks in case the controller is\n       * not a <button>.\n       */\n      this.controllerHandleClick(event);\n    } else if (expanded) {\n      if (ESC === keyCode) {\n        event.preventDefault();\n\n        /*\n         * Close the Popup when the Escape key is pressed. Because focus is not\n         * inside the target (based on the fact that the event was fired on the\n         * controller), there's no need to move focus.\n         */\n        this.hide();\n      } else if (TAB === keyCode) {\n        event.preventDefault();\n\n        /*\n         * When the Popup is open, pressing the TAB key should move focus to the\n         * first interctive child of the target element. This would likely be\n         * the default behavior in most cases, but this patches the behavior in\n         * cases where the markup is disconnected or out-of-order.\n         */\n        this.firstInteractiveChild.focus();\n      }\n    }\n  }\n\n  /**\n   * Handle keydown events on the Popup target.\n   *\n   * @param {Event} event The event object.\n   */\n  targetHandleKeydown(event) {\n    const { ESC, TAB } = keyCodes;\n    const { keyCode, shiftKey } = event;\n    const { expanded } = this.state;\n    const { activeElement } = document;\n\n    if (ESC === keyCode && expanded) {\n      event.preventDefault();\n\n      /*\n       * Close the Popup when the Escape key is pressed.\n       */\n      this.hide();\n\n      /*\n       * Because the activeElement is within the Popup, move focus to the Popup\n       * controller to avoid the confusion of focus being within a hidden\n       * element.\n       */\n      this.controller.focus();\n    } else if (TAB === keyCode) {\n      if (shiftKey) {\n        if ([this.firstInteractiveChild, this.target].includes(activeElement)) {\n          event.preventDefault();\n          /*\n           * Move focus back to the controller if the Shift key is pressed with\n           * the Tab key, but only if the Event target is the Popup's first\n           * interactive child or the Popup itself.\n           */\n          this.controller.focus();\n        }\n      } else if (this.lastInteractiveChild === activeElement) {\n        /*\n         * Close the Popup when tabbing from the last child.\n         */\n        this.hide();\n      }\n    }\n  }\n\n  /**\n   * Toggle the popup state.\n   *\n   * @param {Event} event The event object.\n   */\n  controllerHandleClick(event) {\n    event.preventDefault();\n    const { expanded } = this.state;\n\n    this.setState({ expanded: ! expanded });\n  }\n\n  /**\n   * Close the Popup if the Tab key is pressed and the last interactive child of\n   * the Popup is the event target.\n   *\n   * @param {Event} event The event object.\n   */\n  hideOnTabOut(event) {\n    const { expanded } = this.state;\n    const { TAB } = keyCodes;\n    const { keyCode, shiftKey } = event;\n\n    if (TAB === keyCode && ! shiftKey && expanded) {\n      this.hide();\n    }\n  }\n\n  /**\n   * Close the Popup when clicking anywhere outside of the target or controller\n   * elements.\n   *\n   * @param {Event} event The event object.\n   */\n  hideOnOutsideClick(event) {\n    const { expanded } = this.state;\n    const { target: clicked } = event;\n\n    if (\n      expanded\n      && clicked !== this.controller\n      && ! this.target.contains(clicked)\n    ) {\n      this.hide();\n    }\n  }\n\n  /**\n   * Remove all attributes and event listeners added by this class.\n   */\n  destroy() {\n    // Remove the references to the class instance.\n    this.deleteSelfReferences();\n\n    // Remove IDs set by this class.\n    [this.controller, this.target].forEach((element) => {\n      if (element.getAttribute('id').includes('id_')) {\n        element.removeAttribute('id');\n      }\n    });\n\n    // Remove controller attributes.\n    this.controller.removeAttribute('aria-haspopup');\n    this.controller.removeAttribute('aria-expanded');\n    this.controller.removeAttribute('aria-controls');\n    this.controller.removeAttribute('aria-owns');\n\n    // Remove role and tabindex added to a link controller.\n    if (this.controllerIsNotAButton) {\n      this.controller.removeAttribute('role');\n      this.controller.removeAttribute('tabindex');\n    }\n\n    // Remove target attributes.\n    this.target.removeAttribute('aria-hidden');\n    this.target.removeAttribute('hidden');\n\n    // Remove tabindex attribute.\n    tabIndexAllow(this.interactiveChildElements);\n\n    // Remove event listeners.\n    this.controller.removeEventListener('click', this.controllerHandleClick);\n    this.controller.removeEventListener(\n      'keydown',\n      this.controllerHandleKeydown\n    );\n    this.target.removeEventListener('keydown', this.targetHandleKeydown);\n    document.body.removeEventListener('click', this.hideOnOutsideClick);\n\n    // Reset initial state.\n    this.state = { expanded: false };\n\n    // Run {destroyCallback}\n    this.onDestroy.call(this);\n  }\n\n  /**\n   * Update component state to show the target element.\n   */\n  show() {\n    this.setState({ expanded: true });\n  }\n\n  /**\n   * Update component state to hide the target element.\n   */\n  hide() {\n    this.setState({ expanded: false });\n  }\n}\n","/**\n * Class for searching a list.\n */\nexport default class Search {\n  /**\n   * Create an instance of the Search class.\n   * @constructor\n   */\n  constructor(items) {\n    this.searchString = '';\n    this.clearSearch = null;\n\n    // Make sure `items` is an Array.\n    switch (true) {\n      case Array.isArray(items): {\n        this.items = items;\n        break;\n      }\n      case items instanceof NodeList: {\n        this.items = Array.from(items);\n        break;\n      }\n      case null !== items && 'UL' === items.nodeName: {\n        this.items = Array.from(items.children);\n        break;\n      }\n      default: {\n        this.items = null;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Select the item that matches a search string.\n   * If a match is found, return it so that it can be selected.\n   *\n   * @param {Number} key A keyCode value.\n   * @return {HTMLElement|null} The matched element or null if no match.\n   */\n  getItem(key) {\n    if (null !== this.items) {\n      const character = String.fromCharCode(key);\n\n      // Append the new character to the searchString\n      this.searchString += character;\n\n      if (null !== this.clearSearch) {\n        clearTimeout(this.clearSearch);\n        this.clearSearch = null;\n      }\n\n      // Clear the typed string after timeout.\n      this.clearSearch = setTimeout(() => {\n        this.searchString = '';\n        this.clearSearch = null;\n      }, 500);\n\n      // Find the item by matching the search string to the item text.\n      const match = this.items.filter((item) => {\n        const itemText = item.textContent.toLowerCase();\n        return 0 === itemText.indexOf(this.searchString.toLowerCase());\n      });\n\n      return match.length ? match[0] : null;\n    }\n\n    return null;\n  }\n}\n","import AriaComponent from '../AriaComponent';\nimport Popup from '../Popup';\nimport { setUniqueId } from '../lib/uniqueId';\nimport keyCodes from '../lib/keyCodes';\nimport Search from '../lib/Search';\nimport getFirstAndLastItems from '../lib/getFirstAndLastItems';\n\n/**\n * Class to set up an interactive Listbox element.\n *\n * https://www.w3.org/TR/wai-aria-practices-1.1/#Listbox\n */\nexport default class ListBox extends AriaComponent {\n  /**\n   * Create a ListBox.\n   * @constructor\n   *\n   * @param {HTMLElement} controller The activating element.\n   * @param {object}      options    The options object.\n   */\n  constructor(controller, options = {}) {\n    super(controller);\n\n    this.controller = controller;\n    this.target = super.constructor.getTargetElement(controller);\n\n    /**\n     * The component name.\n     *\n     * @type {string}\n     */\n    this.componentName = 'ListBox';\n\n    /**\n     * Options shape.\n     *\n     * @type {object}\n     */\n    const defaultOptions = {\n      /**\n       * Callback to run after the component initializes.\n       *\n       * @callback initCallback\n       */\n      onInit: () => {},\n\n      /**\n       * Callback to run after component state is updated.\n       *\n       * @callback stateChangeCallback\n       */\n      onStateChange: () => {},\n\n      /**\n       * Callback to run after the component is destroyed.\n       *\n       * @callback destroyCallback\n       */\n      onDestroy: () => {},\n    };\n\n    // Merge options with defaults.\n    Object.assign(this, { ...defaultOptions, ...options });\n\n    // Bind class methods.\n    this.preventWindowScroll = this.preventWindowScroll.bind(this);\n    this.controllerHandleKeyup = this.controllerHandleKeyup.bind(this);\n    this.targetHandleKeydown = this.targetHandleKeydown.bind(this);\n    this.targetHandleClick = this.targetHandleClick.bind(this);\n    this.targetHandleBlur = this.targetHandleBlur.bind(this);\n    this.scrollOptionIntoView = this.scrollOptionIntoView.bind(this);\n    this.onPopupStateChange = this.onPopupStateChange.bind(this);\n    this.show = this.show.bind(this);\n    this.hide = this.hide.bind(this);\n    this.destroy = this.destroy.bind(this);\n    this.stateWasUpdated = this.stateWasUpdated.bind(this);\n\n    this.init();\n  }\n\n  /**\n   * Set up the component's DOM attributes and event listeners.\n   */\n  init() {\n    /*\n     * A reference to the class instance added to the controller and target\n     * elements to enable external interactions with this instance.\n     */\n    super.setSelfReference([this.controller, this.target]);\n\n    /**\n     * The target list items.\n     *\n     * @type {array}\n     */\n    this.options = Array.from(this.target.children);\n\n    /**\n     * Initialize search.\n     * @type {Search}\n     */\n    this.search = new Search(this.options);\n\n    /*\n     * Set the `option` role for each list itme and ensure each has a unique ID.\n     * The ID here is what will be used to track the active descendant.\n     */\n    this.options.forEach((listItem) => {\n      setUniqueId(listItem);\n      listItem.setAttribute('role', 'option');\n    });\n\n    // Save first and last option as properties.\n    const [firstOption, lastOption] = getFirstAndLastItems(this.options);\n    Object.assign(this, { firstOption, lastOption });\n\n    /**\n     * The initial default state.\n     *\n     * The element is saved, rather than just its ID attribute, to remove the\n     * need to query the DOM for it each time we need to act on it.\n     *\n     * @type {HTMLElement}\n     */\n    this.state = { activeDescendant: this.firstOption };\n\n    /**\n     * The Listbox is basically a Popup to present a list of options, so we\n     * instantiate a Popup and subscribe to state changes to act on the Listbox\n     * when the Popup is shown and hidden.\n     *\n     * @type {Popup}\n     */\n    this.popup = new Popup(\n      this.controller,\n      {\n        type: 'listbox',\n        onStateChange: this.onPopupStateChange,\n      }\n    );\n\n    /*\n     * Add the 'listbox' role to signify a component that presents a listbox of\n     * options from which to select.\n     */\n    this.target.setAttribute('role', 'listbox');\n\n    /*\n     * Set up the target element to allow programatically setting focus to it\n     * when the Listbox opens.\n     *\n     * @see this.stateWasUpdated()\n     */\n    this.target.setAttribute('tabindex', '-1');\n\n    // Add event listeners.\n    this.controller.addEventListener('keydown', this.controllerHandleKeyup);\n    this.target.addEventListener('keydown', this.targetHandleKeydown);\n    this.target.addEventListener('click', this.targetHandleClick);\n    this.target.addEventListener('blur', this.targetHandleBlur);\n\n    // Prevent scrolling when using UP/DOWN arrows on the button\n    window.addEventListener('keydown', this.preventWindowScroll);\n\n    // Run {initCallback}\n    this.onInit.call(this);\n  }\n\n  /**\n   * Track the selected Listbox option.\n   * https://www.w3.org/TR/wai-aria-practices-1.1/#kbd_focus_activedescendant\n   *\n   * @param {object} state The component state.\n   * @param {HTMLElement} state.activeDescendant The expected `activeDescendant` state.\n   */\n  stateWasUpdated() {\n    const { activeDescendant, expanded } = this.state;\n\n    if (expanded) {\n      /*\n       * Remove the `aria-selected` attribute from the previously-selected option\n       * and add it to the newly-selected option.\n       */\n      const selected = this.target.querySelector('[aria-selected=\"true\"]');\n      if (null !== selected) {\n        selected.removeAttribute('aria-selected');\n      }\n      activeDescendant.setAttribute('aria-selected', 'true');\n\n      /*\n       * Track the newly selected option via the `aria-activedescendant` attribute\n       * on the target.\n       */\n      this.target.setAttribute('aria-activedescendant', activeDescendant.id);\n\n      /*\n       * If the selected option is beyond the bounds of the list, scroll it into\n       * view. Check this every time state is updated to ensure the selected\n       * option is always visible.\n       */\n      this.scrollOptionIntoView(activeDescendant);\n    }\n\n    // Run {stateChangeCallback}\n    this.onStateChange.call(this, this.state);\n  }\n\n  /**\n   * Subscribe to Popup state changes.\n   *\n   * @param {object} popup.state the Popup state.\n   * @param {boolean} popup.state.expanded The Popup `expanded` state.\n   */\n  onPopupStateChange({ expanded }) {\n    const { activeDescendant } = this.state;\n\n    if (expanded) {\n      /*\n       * Focus the target (list) element when the Listbox is shown. Focus\n       * remains on the target element, with option selection coming through a\n       * combination of the `aria-selected` attribute on the option and the\n       * `aria-activedescendant` attribute on the target tracking the active\n       * option.\n       */\n      this.target.focus();\n    } else {\n      /*\n       * When the Popup is hidden, the `aria-activedescendant` attribute should\n       * be removed from the list and the selected option should be used as the\n       * button text.\n       */\n      this.target.removeAttribute('aria-activedescendant');\n      this.controller.textContent = activeDescendant.textContent;\n\n      /*\n       * If focus is within the Listbox, move focus to the controller. This\n       * check is in place to avoid moving focus to the controller if an element\n       * outside of the Listbox is clicked.\n       */\n      if (this.target.contains(document.activeElement)) {\n        this.controller.focus();\n      }\n    }\n\n    // Update component state.\n    this.setState({ activeDescendant, expanded });\n  }\n\n  /**\n   * Prevent the page from scrolling when the arrow keys are used.\n   *\n   * @param {Event} event The event object.\n   */\n  preventWindowScroll(event) {\n    const { UP, DOWN } = keyCodes;\n    const { target: keydownTarget, keyCode } = event;\n\n    if (keydownTarget === this.target && [UP, DOWN].includes(keyCode)) {\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * Handle keyup events on the button.\n   * Both the UP and DOWN arrow keys should show the Listbox popup.\n   *\n   * @param {Event} event The event object.\n   */\n  controllerHandleKeyup(event) {\n    const { UP, DOWN } = keyCodes;\n\n    if ([UP, DOWN].includes(event.keyCode)) {\n      event.preventDefault();\n\n      this.show();\n    }\n  }\n\n  /**\n   * Handle keydown events on the listbox.\n   *\n   * @param {Event} event The event object.\n   */\n  targetHandleKeydown(event) {\n    const { activeDescendant } = this.state;\n    const { keyCode } = event;\n    const {\n      RETURN,\n      ESC,\n      UP,\n      DOWN,\n      SPACE,\n      HOME,\n      END,\n    } = keyCodes;\n\n    switch (keyCode) {\n      /*\n       * Close the Listbox when the Return, Escape, or Spacebar are pressed. No\n       * need to update state here; if the Listbox is open rest assured an\n       * option is selected.\n       */\n      case ESC:\n      case RETURN:\n      case SPACE: {\n        event.preventDefault();\n        this.hide();\n\n        // Move focus to the controller when the Listbox is closed.\n        this.controller.focus();\n\n        break;\n      }\n\n      /*\n       * Select the next or previous Listbox option.\n       */\n      case UP:\n      case DOWN: {\n        let moveTo = activeDescendant;\n\n        moveTo = (keyCode === UP)\n          ? moveTo.previousElementSibling\n          : moveTo.nextElementSibling;\n\n        if (moveTo) {\n          event.preventDefault();\n          this.setState({ activeDescendant: moveTo });\n        }\n\n        break;\n      }\n\n      /*\n       * Select the first Listbox option.\n       */\n      case HOME: {\n        event.preventDefault();\n        this.setState({ activeDescendant: this.firstOption });\n\n        break;\n      }\n\n      /*\n       * Select the last Listbox option.\n       */\n      case END: {\n        event.preventDefault();\n        this.setState({ activeDescendant: this.lastOption });\n\n        break;\n      }\n\n      /*\n       * Select the Listbox option based on a search string created by\n       * collecting key presses.\n       */\n      default: {\n        const itemToFocus = this.search.getItem(keyCode);\n        if (null !== itemToFocus) {\n          this.setState({ activeDescendant: itemToFocus });\n        }\n\n        break;\n      }\n    }\n  }\n\n  /**\n   * Close the Listbox, but not before updating state to reflect the option that\n   * was clicked.\n   *\n   * @param {Event} event The event object.\n   */\n  targetHandleClick(event) {\n    this.setState({ activeDescendant: event.target });\n    this.hide();\n  }\n\n  /**\n   * Close the Listbox when focus is moved away from the target.\n   */\n  targetHandleBlur() {\n    // Use Popup state here, since the Popup drives the Listbox state.\n    if (this.popup.getState().expanded) {\n      this.hide();\n    }\n  }\n\n  /**\n   * If the Listbox is scrollable, and the selected option is not visible,\n   * scroll it into view.\n   *\n   * @param {HTMLElement} moveTo The element getting focus.\n   */\n  scrollOptionIntoView(moveTo) {\n    const { scrollHeight, clientHeight, scrollTop } = this.target;\n    const { offsetTop, offsetHeight } = moveTo;\n\n    if (scrollHeight > clientHeight) {\n      const scrollBottom = clientHeight + scrollTop;\n      const elementBottom = offsetTop + offsetHeight;\n\n      if (elementBottom > scrollBottom) {\n        this.target.scrollTop = elementBottom - clientHeight;\n      } else if (offsetTop < scrollTop) {\n        this.target.scrollTop = offsetTop;\n      }\n    }\n  }\n\n  /**\n   * Destroy the Listbox and Popup.\n   */\n  destroy() {\n    // Remove the references to the class instance.\n    this.deleteSelfReferences();\n\n    // Remove the role attribute from each of the options.\n    this.options.forEach((listItem) => {\n      listItem.removeAttribute('role');\n      listItem.removeAttribute('aria-selected');\n\n      // Remove IDs set by this class.\n      if (listItem.getAttribute('id').includes('id_')) {\n        listItem.removeAttribute('id');\n      }\n    });\n\n    // Destroy the Popup.\n    this.popup.destroy();\n\n    // Remove the listbox role.\n    this.target.removeAttribute('role');\n    this.target.removeAttribute('tabindex');\n    this.target.removeAttribute('aria-activedescendant');\n\n    // Remove event listeners.\n    this.controller.removeEventListener('keyup', this.controllerHandleKeyup);\n    this.target.removeEventListener('keydown', this.targetHandleKeydown);\n    this.target.removeEventListener('click', this.targetHandleClick);\n    this.target.removeEventListener('blur', this.targetHandleBlur);\n    window.removeEventListener('keydown', this.preventWindowScroll);\n\n    // Run {destroyCallback}\n    this.onDestroy.call(this);\n  }\n\n  /**\n   * Show the Listbox.\n   */\n  show() {\n    this.popup.show();\n  }\n\n  /**\n   * Hide the Listbox.\n   */\n  hide() {\n    this.popup.hide();\n  }\n}\n","import AriaComponent from '../AriaComponent';\nimport keyCodes from '../lib/keyCodes';\nimport interactiveChildren from '../lib/interactiveChildren';\nimport { tabIndexDeny, tabIndexAllow } from '../lib/rovingTabIndex';\nimport { setUniqueId } from '../lib/uniqueId';\n\n/**\n * Class to set up a controller-target relationship for independently revealing\n * and hiding inline content.\n *\n * https://www.w3.org/TR/wai-aria-practices-1.1/#disclosure\n */\nexport default class Disclosure extends AriaComponent {\n  /**\n   * Create a Disclosure.\n   * @constructor\n   *\n   * @param {HTMLElement} controller The activating element.\n   * @param {object}      options    The options object.\n   */\n  constructor(controller, options = {}) {\n    super(controller);\n\n    this.controller = controller;\n    this.target = super.constructor.getTargetElement(controller);\n\n    /**\n     * The component name.\n     *\n     * @type {string}\n     */\n    this.componentName = 'Disclosure';\n\n    /**\n     * Options shape.\n     *\n     * @type {object}\n     */\n    const defaultOptions = {\n      /**\n       * Load the Disclosure open by default.\n       *\n       * @type {boolean}\n       */\n      loadOpen: false,\n\n      /**\n       * Keep the Disclosure open when the user clicks outside of it.\n       *\n       * @type {boolean}\n       */\n      allowOutsideClick: true,\n\n      /**\n       * Callback to run after the component initializes.\n       *\n       * @callback initCallback\n       */\n      onInit: () => {},\n\n      /**\n       * Callback to run after component state is updated.\n       *\n       * @callback stateChangeCallback\n       */\n      onStateChange: () => {},\n\n      /**\n       * Callback to run after the component is destroyed.\n       *\n       * @callback destroyCallback\n       */\n      onDestroy: () => {},\n    };\n\n    // Merge options with defaults and save all as instance properties.\n    Object.assign(this, { ...defaultOptions, ...options });\n\n    // Initial component state.\n    this.state = { expanded: this.loadOpen };\n\n    // Bind class methods.\n    this.init = this.init.bind(this);\n    this.destroy = this.destroy.bind(this);\n    this.open = this.open.bind(this);\n    this.close = this.close.bind(this);\n    this.controllerHandleKeydown = this.controllerHandleKeydown.bind(this);\n    this.toggleExpandedState = this.toggleExpandedState.bind(this);\n    this.closeOnOutsideClick = this.closeOnOutsideClick.bind(this);\n    this.stateWasUpdated = this.stateWasUpdated.bind(this);\n\n    this.init();\n  }\n\n  /**\n   * Add initial attributes, establish relationships, and listen for events\n   */\n  init() {\n    /*\n     * A reference to the class instance added to the controller and target\n     * elements to enable external interactions with this instance.\n     */\n    super.setSelfReference([this.controller, this.target]);\n\n    // Component state is initially set in the constructor.\n    const { expanded } = this.state;\n\n    /**\n     * Collect the target element's interactive child elements.\n     * @type {array}\n     */\n    this.interactiveChildElements = interactiveChildren(this.target);\n\n    // Ensure the target and controller each have an ID attribute.\n    [this.controller, this.target].forEach((element) => {\n      setUniqueId(element);\n    });\n\n    // Add controller attributes\n    this.controller.setAttribute('aria-expanded', `${expanded}`);\n    this.controller.setAttribute('aria-controls', this.target.id);\n\n    // Patch button role and behavior for non-button controller.\n    if ('BUTTON' !== this.controller.nodeName) {\n      /*\n       * Some elements semantics conflict with the button role. You really\n       * should just use a button.\n       */\n      this.controller.setAttribute('role', 'button');\n\n      // Ensure we can TAB to the controller if it's not a button or anchor.\n      if (\n        'A' !== this.controller.nodeName\n        && null === this.controller.getAttribute('tabindex')\n      ) {\n        this.controller.setAttribute('tabindex', '0');\n      }\n    }\n\n    /*\n     * Establishes a relationship when the DOM heirarchy doesn't represent that\n     * a relationship exists.\n     */\n    if (this.target !== this.controller.nextElementSibling) {\n      this.controller.setAttribute('aria-owns', this.target.id);\n    }\n\n    /*\n     * Set the taget as hidden by default. Using the `aria-hidden` attribute,\n     * rather than the `hidden` attribute, means authors must hide the target\n     * element via CSS.\n     */\n    if (! expanded) {\n      this.target.setAttribute('aria-hidden', 'true');\n      this.target.setAttribute('hidden', '');\n    }\n\n    // Add event listeners\n    this.controller.addEventListener('click', this.toggleExpandedState);\n    this.controller.addEventListener('keydown', this.controllerHandleKeydown);\n    if (! this.allowOutsideClick) {\n      document.body.addEventListener('click', this.closeOnOutsideClick);\n    }\n\n    /*\n     * Prevent focus on interactive elements in the target when the target is\n     * hidden. This isn't such an issue when the target is hidden with\n     * `display:none`, but is necessary if the target is hidden by other means,\n     * such as minimized height or width.\n     */\n    tabIndexDeny(this.interactiveChildElements);\n\n    // Run {initCallback}\n    this.onInit.call(this);\n  }\n\n  /**\n   * Update the component attributes based on updated state.\n   *\n   * @param {object} state The component state.\n   * @param {boolean} state.expanded The expected `expanded` state.\n   */\n  stateWasUpdated() {\n    const { expanded } = this.state;\n\n    this.controller.setAttribute('aria-expanded', `${expanded}`);\n\n    /*\n     * https://developer.paciellogroup.com/blog/2016/01/the-state-of-hidden-content-support-in-2016/\n     *\n     * > In some browser and screen reader combinations aria-hidden=false on an\n     *   element that is hidden using the hidden attribute or CSS display:none\n     *   results in the content being unhidden.\n     */\n    if (expanded) {\n      this.target.setAttribute('aria-hidden', 'false');\n      this.target.removeAttribute('hidden');\n    } else {\n      this.target.setAttribute('aria-hidden', 'true');\n      this.target.setAttribute('hidden', '');\n    }\n\n    // Allow or deny keyboard focus depending on component state.\n    if (expanded) {\n      tabIndexAllow(this.interactiveChildElements);\n    } else {\n      tabIndexDeny(this.interactiveChildElements);\n    }\n\n    // Run {stateChangeCallback}\n    this.onStateChange.call(this, this.state);\n  }\n\n  /**\n   * Handle keydown events on the Disclosure controller.\n   *\n   * @param {Event} event The event object.\n   */\n  controllerHandleKeydown(event) {\n    const { SPACE, RETURN } = keyCodes;\n    const { keyCode } = event;\n\n    if ([SPACE, RETURN].includes(keyCode)) {\n      /*\n       * Treat the Spacebar and Return keys as clicks in case the controller is\n       * not a <button>.\n       */\n      this.toggleExpandedState(event);\n    }\n  }\n\n  /**\n   * Toggle the expanded state.\n   *\n   * @param {Event} event The Event object.\n   */\n  toggleExpandedState(event) {\n    event.preventDefault();\n\n    if (this.state.expanded) {\n      this.close();\n    } else {\n      this.open();\n    }\n  }\n\n  /**\n   * Close the disclosure when the user clicks outside of the target.\n   *\n   * @param {Event} event The Event object.\n   */\n  closeOnOutsideClick(event) {\n    if (\n      this.state.expanded\n      && event.target !== this.controller\n      && ! this.target.contains(event.target)\n    ) {\n      this.close();\n    }\n  }\n\n  /**\n   * Remove all ARIA attributes added by this class.\n   */\n  destroy() {\n    // Remove the references to the class instance.\n    this.deleteSelfReferences();\n\n    // Remove IDs set by this class.\n    [this.controller, this.target].forEach((element) => {\n      if (element.getAttribute('id').includes('id_')) {\n        element.removeAttribute('id');\n      }\n    });\n\n    // Remove controller attributes.\n    this.controller.removeAttribute('aria-expanded');\n    this.controller.removeAttribute('aria-controls');\n    this.controller.removeAttribute('aria-owns');\n    this.controller.removeAttribute('tabindex');\n\n    if ('BUTTON' !== this.controller.nodeName) {\n      this.controller.removeAttribute('role');\n    }\n\n    // Remove target attributes.\n    this.target.removeAttribute('aria-hidden');\n    this.target.removeAttribute('hidden');\n\n    // Remove tabindex attributes.\n    tabIndexAllow(this.interactiveChildElements);\n\n    // Remove event listeners.\n    this.controller.removeEventListener('click', this.toggleExpandedState);\n    this.controller.removeEventListener(\n      'keydown',\n      this.controllerHandleKeydown\n    );\n    document.body.removeEventListener('click', this.closeOnOutsideClick);\n\n    // Reset initial state.\n    this.state = { expanded: this.loadOpen };\n\n    // Run {destroyCallback}\n    this.onDestroy.call(this);\n  }\n\n  /**\n   * Update component state to open the Disclosure.\n   */\n  open() {\n    this.setState({ expanded: true });\n  }\n\n  /**\n   * Update component state to close the Disclosure.\n   */\n  close() {\n    this.setState({ expanded: false });\n  }\n}\n","/**\n * Check if a given element's property has been instantiated as an AriaComponent class.\n *\n * @param {HTMLElement} prop      The property to check.\n * @param {Object}      component The class instance to check against.\n * @return {Boolean}\n */\nexport default function isInstanceOf(prop, component) {\n  if (undefined === prop || null === prop) {\n    return false;\n  }\n\n  return (prop instanceof component);\n}\n","import keyCodes from './keyCodes';\n\nfunction nextPrevious(keyCode, activeDescendant, menuItems, keys) {\n  const { next, previous } = keys;\n  const activeIndex = menuItems.indexOf(activeDescendant);\n  const menuLastIndex = menuItems.length - 1;\n\n  // Determine the direction.\n  let newIndex = (keyCode === previous) ? activeIndex - 1 : activeIndex + 1;\n\n  // Move to the end if we're moving to the previous child from the first child.\n  if (previous === keyCode && 0 > newIndex) {\n    newIndex = menuLastIndex;\n  }\n\n  // Move to first child if we're at the end.\n  if (next === keyCode && menuLastIndex < newIndex) {\n    newIndex = 0;\n  }\n\n  return menuItems[newIndex];\n}\n\nfunction nextPreviousFromUpDown(keyCode, activeDescendant, menuItems) {\n  const { UP, DOWN } = keyCodes;\n  return nextPrevious(\n    keyCode,\n    activeDescendant,\n    menuItems,\n    { previous: UP, next: DOWN }\n  );\n}\n\nfunction nextPreviousFromLeftRight(keyCode, activeDescendant, menuItems) {\n  const { LEFT, RIGHT } = keyCodes;\n  return nextPrevious(\n    keyCode,\n    activeDescendant,\n    menuItems,\n    { previous: LEFT, next: RIGHT }\n  );\n}\n\nexport {\n  nextPrevious,\n  nextPreviousFromUpDown,\n  nextPreviousFromLeftRight,\n};\n","import AriaComponent from '../AriaComponent';\nimport Disclosure from '../Disclosure';\nimport keyCodes from '../lib/keyCodes';\nimport isInstanceOf from '../lib/isInstanceOf';\nimport { nextPreviousFromUpDown } from '../lib/nextPrevious';\nimport Search from '../lib/Search';\nimport getFirstAndLastItems from '../lib/getFirstAndLastItems';\n\n/**\n * Class to set up an vertically oriented interactive Menu element.\n *\n * https://www.w3.org/TR/wai-aria-practices-1.1/#menu\n */\nexport default class Menu extends AriaComponent {\n  /**\n   * Test for a list as the next sibling element.\n   *\n   * @param {HTMLElement} element The element whose sibling we're testing.\n   * @return {HTMLElement|boolean}\n   */\n  static nextElementIsUl(element) {\n    const next = element.nextElementSibling;\n    return (null !== next && 'UL' === next.nodeName) ? next : false;\n  }\n\n  /**\n   * Create a Menu.\n   * @constructor\n   *\n   * @param {HTMLUListElement} element The menu list element.\n   * @param {object}           options The options object.\n   */\n  constructor(list, options = {}) {\n    super(list);\n\n    if ('UL' !== list.nodeName) {\n      AriaComponent.configurationError(\n        'The Menu element nodeName must be `UL`'\n      );\n    }\n\n    this.list = list;\n\n    /**\n     * The component name.\n     *\n     * @type {string}\n     */\n    this.componentName = 'Menu';\n\n    /**\n     * Options shape.\n     *\n     * @type {object}\n     */\n    const defaultOptions = {\n      /**\n       * Instantiate submenus as Disclosures.\n       *\n       * @type {Boolean}\n       */\n      collapse: false,\n\n      /**\n       * Selector used to validate menu items.\n       *\n       * This can also be used to exclude items that would otherwise be given a\n       * \"menuitem\" role; e.g., `:not(.hidden)`.\n       *\n       * @type {string}\n       */\n      itemMatches: '*',\n\n      /**\n       * Callback to run after the component initializes.\n       *\n       * @callback initCallback\n       */\n      onInit: () => {},\n\n      /**\n       * Callback to run after the component is destroyed.\n       *\n       * @callback destroyCallback\n       */\n      onDestroy: () => {},\n    };\n\n    // Merge options with defaults.\n    Object.assign(this, { ...defaultOptions, ...options });\n\n    // Bind class methods\n    this.listHandleKeydown = this.listHandleKeydown.bind(this);\n    this.destroy = this.destroy.bind(this);\n\n    this.init();\n  }\n\n  /**\n   * Collect menu links and recursively instantiate sublist menu items.\n   */\n  init() {\n    /*\n     * A reference to the class instance added to the controller and target\n     * elements to enable external interactions with this instance.\n     */\n    super.setSelfReference([this.list]);\n\n    /*\n     * Add the 'menu' role to signify a widget that offers a list of choices to\n     * the user, such as a set of actions or functions.\n     */\n    this.list.setAttribute('role', 'menu');\n\n    /**\n     * The list's child elements.\n     *\n     * @type {array}\n     */\n    this.listItems = Array.from(this.list.children);\n\n    /**\n     * Collected menu links.\n     *\n     * @type {array}\n     */\n    this.menuItems = this.listItems.reduce((acc, item) => {\n      const [firstChild, ...theRest] = Array.from(item.children);\n\n      // Try to use the first child of the menu item.\n      let itemLink = firstChild;\n\n      // If the first child isn't a link or button, find the first instance of either.\n      if (null === itemLink || ! itemLink.matches('a,button')) {\n        [itemLink] = Array.from(theRest)\n          .filter((child) => child.matches('a,button'));\n      }\n\n      if (undefined !== itemLink && itemLink.matches(this.itemMatches)) {\n        return [...acc, itemLink];\n      }\n\n      return acc;\n    }, []);\n\n    /**\n     * Initialize search.\n     * @type {Search}\n     */\n    this.search = new Search(this.menuItems);\n\n    /**\n     * The number of menu items.\n     *\n     * @type {number}\n     */\n    this.menuItemsLength = this.menuItems.length;\n\n    /**\n     * Listen for keydown events on the menu.\n     */\n    this.list.addEventListener('keydown', this.listHandleKeydown);\n\n    /**\n     * The submenu Disclosures.\n     *\n     * @type {array}\n     */\n    this.disclosures = [];\n\n    /*\n     * Set menu link attributes and instantiate submenus.\n     */\n    this.menuItems.forEach((link, index) => {\n      // Remove semantics from list items.\n      link.parentElement.setAttribute('role', 'presentation');\n\n      // Set the menuitem role.\n      link.setAttribute('role', 'menuitem');\n\n      // Add size and position attributes.\n      link.setAttribute('aria-setsize', this.menuItemsLength);\n      link.setAttribute('aria-posinset', index + 1);\n\n      // Instantiate submenu Disclosures\n      if (this.collapse && link.hasAttribute('target')) {\n        const disclosure = new Disclosure(link);\n\n        this.disclosures.push(disclosure);\n      }\n\n      const siblingList = this.constructor.nextElementIsUl(link);\n      if (siblingList) {\n        // Instantiate sub-Menus.\n        const subList = new Menu(siblingList);\n        // Save the list's previous sibling.\n        subList.previousSibling = link;\n      }\n    });\n\n    // Save the menu's first and last items.\n    const [firstItem, lastItem] = getFirstAndLastItems(this.menuItems);\n    Object.assign(this, { firstItem, lastItem });\n\n    // Run {initCallback}\n    this.onInit.call(this);\n  }\n\n  /**\n   * Handle keydown events on menu items.\n   *\n   * @param {Event} event The event object.\n   */\n  listHandleKeydown(event) {\n    const { keyCode } = event;\n    const {\n      UP,\n      DOWN,\n      LEFT,\n      RIGHT,\n      HOME,\n      END,\n      ESC,\n    } = keyCodes;\n    const { activeElement } = document;\n    const activeDescendant = (this.list.contains(activeElement)\n      ? activeElement\n      : this.menuItems[0]);\n\n    switch (keyCode) {\n      /*\n       * Move through sibling list items.\n       */\n      case UP:\n      case DOWN: {\n        const nextItem = nextPreviousFromUpDown(\n          keyCode,\n          activeDescendant,\n          this.menuItems\n        );\n\n        if (nextItem) {\n          event.stopPropagation();\n          event.preventDefault();\n\n          nextItem.focus();\n        }\n\n        break;\n      }\n\n      /*\n       * Select the first Menu item.\n       */\n      case HOME: {\n        event.preventDefault();\n\n        this.firstItem.focus();\n\n        break;\n      }\n\n      /*\n       * Select the last Menu item.\n       */\n      case END: {\n        event.preventDefault();\n\n        this.lastItem.focus();\n\n        break;\n      }\n\n      /*\n       * Drill down into a nested list, if present.\n       */\n      case RIGHT: {\n        const siblingElement = this.constructor.nextElementIsUl(activeDescendant); // eslint-disable-line max-len\n\n        if (siblingElement && isInstanceOf(siblingElement.menu, Menu)) {\n          event.stopPropagation();\n          event.preventDefault();\n\n          // Open the submenu Disclosure.\n          if (isInstanceOf(activeDescendant.disclosure, Disclosure)) {\n            activeDescendant.disclosure.open();\n          }\n\n          const { menu } = siblingElement;\n          menu.firstItem.focus();\n        }\n\n        break;\n      }\n\n      /*\n       * Move up to the list's previous sibling, if present.\n       */\n      case LEFT: {\n        if (\n          undefined !== this.previousSibling\n          && ! this.previousSibling.hasAttribute('aria-haspopup')\n        ) {\n          // The previous sibling is not a Popup.\n          event.preventDefault();\n          event.stopPropagation();\n\n          // Close the submenu Disclosure.\n          if (isInstanceOf(this.previousSibling.disclosure, Disclosure)) {\n            this.previousSibling.disclosure.close();\n          }\n\n          this.previousSibling.focus();\n        }\n\n        break;\n      }\n\n      /*\n       * Listen for the ESC key to prevent it from being caught as a search\n       * string. Otherwise the MenuButton won't close as expected.\n       */\n      case ESC: {\n        // do nothing.\n        break;\n      }\n\n      /*\n       * Select the Menu item based on a search string created by\n       * collecting key presses.\n       */\n      default: {\n        event.stopPropagation();\n        const itemToFocus = this.search.getItem(keyCode);\n        if (null !== itemToFocus) {\n          itemToFocus.focus();\n        }\n\n        break;\n      }\n    }\n  }\n\n  /**\n   * Destroy the Menu and any submenus.\n   */\n  destroy() {\n    // Remove the reference to the class instance.\n    this.deleteSelfReferences();\n\n    // Remove the list's role attritbute.\n    this.list.removeAttribute('role');\n\n    // Remove event listener.\n    this.list.removeEventListener('keydown', this.listHandleKeydown);\n\n    this.menuItems.forEach((link) => {\n      // Remove list item role.\n      link.parentElement.removeAttribute('role');\n\n      // Remove menuitem attributes.\n      link.removeAttribute('role');\n      link.removeAttribute('aria-setsize');\n      link.removeAttribute('aria-posinset');\n\n      // Destroy nested Menus.\n      const siblingList = this.constructor.nextElementIsUl(link);\n      if (siblingList && isInstanceOf(siblingList.menu, Menu)) {\n        siblingList.menu.destroy();\n      }\n    });\n\n    // Destroy inner Disclosure(s).\n    this.disclosures.forEach((disclosure) => {\n      disclosure.destroy();\n    });\n\n    // Run {destroyCallback}\n    this.onDestroy.call(this);\n  }\n}\n","import AriaComponent from '../AriaComponent';\nimport Popup from '../Popup';\nimport Menu from '../Menu';\nimport keyCodes from '../lib/keyCodes';\nimport { rovingTabIndex, tabIndexAllow } from '../lib/rovingTabIndex';\nimport { nextPreviousFromLeftRight } from '../lib/nextPrevious';\nimport isInstanceOf from '../lib/isInstanceOf';\nimport Search from '../lib/Search';\nimport getFirstAndLastItems from '../lib/getFirstAndLastItems';\n\n/**\n * Class for managing a visually persistent (horizontally-oriented) menubar,\n * with each submenu item is instantiated as a Popup.\n *\n * https://www.w3.org/TR/wai-aria-practices-1.1/#menu\n * https://www.w3.org/TR/wai-aria-1.1/#menubar\n */\nexport default class MenuBar extends AriaComponent {\n  /**\n   * Save the menuBar item's popup, if it exists.\n   *\n   * @param {HTMLElement} menubarItem The current menubarItem from state.\n   * @return {Popup|Boolean} The menubarItem's popup, or false if none.\n   */\n  static getPopupFromMenubarItem(menubarItem) {\n    return isInstanceOf(menubarItem.popup, Popup)\n      ? menubarItem.popup\n      : false;\n  }\n\n  /**\n   * Create a MenuBar.\n   * @constructor\n   *\n   * @param {HTMLUListElement} element The menu list element.\n   * @param {object}           options The options object.\n   */\n  constructor(list, options = {}) {\n    super(list);\n\n    if ('UL' !== list.nodeName) {\n      AriaComponent.configurationError(\n        'The MenuBar element nodeName must be `UL`'\n      );\n    }\n\n    this.list = list;\n\n    /**\n     * The component name.\n     *\n     * @type {string}\n     */\n    this.componentName = 'MenuBar';\n\n    /**\n     * Options shape.\n     *\n     * @type {object}\n     */\n    const defaultOptions = {\n      /**\n       * Selector used to validate menu items.\n       *\n       * This can also be used to exclude items that would otherwise be given a\n       * \"menuitem\" role; e.g., `:not(.hidden)`.\n       *\n       * @type {string}\n       */\n      itemMatches: '*',\n\n      /**\n       * Callback to run after the component initializes.\n       *\n       * @callback initCallback\n       */\n      onInit: () => {},\n\n      /**\n       * Callback to run after component state is updated.\n       *\n       * @callback stateChangeCallback\n       */\n      onStateChange: () => {},\n\n      /**\n       * Callback to run after the component is destroyed.\n       *\n       * @callback destroyCallback\n       */\n      onDestroy: () => {},\n\n      /**\n       * Callback to run after Popup initializes.\n       *\n       * @callback popupInitCallback\n       */\n      onPopupInit: () => {},\n    };\n\n    // Merge options with defaults.\n    Object.assign(this, { ...defaultOptions, ...options });\n\n    // Bind class methods.\n    this.menubarHandleKeydown = this.menubarHandleKeydown.bind(this);\n    this.menubarHandleClick = this.menubarHandleClick.bind(this);\n    this.menuItemHandleKeydown = this.menuItemHandleKeydown.bind(this);\n    this.stateWasUpdated = this.stateWasUpdated.bind(this);\n    this.destroy = this.destroy.bind(this);\n\n    this.init();\n  }\n\n  /**\n   * Collect top-level menu items and set up event handlers.\n   */\n  init() {\n    /*\n     * A reference to the class instance added to the controller and target\n     * elements to enable external interactions with this instance.\n     */\n    super.setSelfReference([this.list]);\n\n    // Set the menu role.\n    this.list.setAttribute('role', 'menubar');\n\n    /**\n     * The menubar's child elements.\n     *\n     * @type {array}\n     */\n    this.menuBarChildren = Array.from(this.list.children);\n\n    /**\n     * Collected menubar links.\n     *\n     * @type {array}\n     */\n    this.menuBarItems = this.menuBarChildren.reduce((acc, item) => {\n      const [firstChild, ...theRest] = Array.from(item.children);\n\n      // Try to use the first child of the menu item.\n      let itemLink = firstChild;\n\n      // If the first child isn't a link or button, find the first instance of either.\n      if (null === itemLink || ! itemLink.matches('a,button')) {\n        [itemLink] = Array.from(theRest)\n          .filter((child) => child.matches('a,button'));\n      }\n\n      if (undefined !== itemLink && itemLink.matches(this.itemMatches)) {\n        return [...acc, itemLink];\n      }\n\n      return acc;\n    }, []);\n\n    /**\n     * Initialize search.\n     *\n     * @type {Search}\n     */\n    this.search = new Search(this.menuBarItems);\n\n    /**\n     * The number of menubar items.\n     *\n     * @type {number}\n     */\n    this.menuLength = this.menuBarItems.length;\n\n    /*\n     * Set menubar link attributes.\n     */\n    this.menuBarItems.forEach((link, index) => {\n      // Set the item's role.\n      link.setAttribute('role', 'menuitem');\n\n      // Add size and position attributes.\n      link.setAttribute('aria-setsize', this.menuLength);\n      link.setAttribute('aria-posinset', index + 1);\n\n      // Set menubar item role.\n      link.parentElement.setAttribute('role', 'presentation');\n\n      link.parentElement.addEventListener('keydown', this.menubarHandleKeydown);\n      link.addEventListener('click', this.menubarHandleClick);\n    });\n\n    // Collect first and last MenuBar items and merge them in as instance properties.\n    const [firstItem, lastItem] = getFirstAndLastItems(this.menuBarItems);\n    Object.assign(this, { firstItem, lastItem });\n\n    /**\n     * A mouse 'click' event.\n     *\n     * @type {MouseEvent}\n     */\n    this.clickEvent = new MouseEvent('click', {\n      view: window,\n      bubbles: true,\n      cancelable: true,\n    });\n\n    // Initialize popups for nested lists.\n    const { popups, subMenus } = this.menuBarItems.reduce((acc, controller) => {\n      // Bail if there's no target attribute.\n      if (! controller.hasAttribute('target')) {\n        return acc;\n      }\n\n      const popup = new Popup(\n        controller,\n        {\n          onInit: this.onPopupInit,\n          type: 'menu',\n        }\n      );\n\n      acc.popups.push(popup);\n\n      const { target } = popup;\n\n      // If target isn't a UL, find the UL in target and use it.\n      const list = ('UL' === target.nodeName)\n        ? target\n        : target.querySelector('ul');\n\n      // Bail if there's no list.\n      if (null === list) {\n        return acc;\n      }\n\n      // Initialize submenu Menus.\n      const subMenu = new Menu(list, { itemMatches: this.itemMatches });\n      target.addEventListener('keydown', this.menuItemHandleKeydown);\n\n      // Save the list's previous sibling.\n      subMenu.previousSibling = controller;\n      acc.subMenus.push(subMenu);\n\n      return acc;\n    }, { popups: [], subMenus: [] });\n\n    // Save components as instance properties.\n    Object.assign(this, { popups, subMenus });\n\n    /**\n     * Set initial state.\n     *\n     * @type {object}\n     */\n    this.state = {\n      menubarItem: this.firstItem,\n      popup: this.constructor.getPopupFromMenubarItem(this.firstItem),\n      expanded: false,\n    };\n\n    // Set up initial tabindex.\n    rovingTabIndex(this.menuBarItems, this.firstItem);\n\n    // Run {initCallback}\n    this.onInit.call(this);\n  }\n\n  /**\n   * Manage menubar state.\n   *\n   * @param {Object} state The component state.\n   */\n  stateWasUpdated() {\n    const { menubarItem } = this.state;\n\n    // Prevent tabbing to all but the currently-active menubar item.\n    rovingTabIndex(this.menuBarItems, menubarItem);\n\n    menubarItem.focus();\n\n    // Run {stateChangeCallback}\n    this.onStateChange.call(this, this.state);\n  }\n\n  /**\n   * Handle keydown events on the menuList element.\n   *\n   * @param {Object} event The event object.\n   */\n  menubarHandleKeydown(event) {\n    const {\n      LEFT,\n      RIGHT,\n      DOWN,\n      HOME,\n      END,\n      SPACE,\n      RETURN,\n    } = keyCodes;\n    const { keyCode } = event;\n    const { menubarItem } = this.state;\n    const popup = this.constructor.getPopupFromMenubarItem(menubarItem);\n\n    switch (keyCode) {\n      /*\n       * Move through sibling list items.\n       */\n      case LEFT:\n      case RIGHT: {\n        const nextItem = nextPreviousFromLeftRight(\n          keyCode,\n          menubarItem,\n          this.menuBarItems\n        );\n\n        if (nextItem) {\n          event.stopPropagation();\n          event.preventDefault();\n\n          // Close the popup.\n          if (popup) {\n            popup.hide();\n          }\n\n          this.setState({\n            menubarItem: nextItem,\n          });\n        }\n\n        break;\n      }\n\n      /*\n       * Open the popup if it exists and is not expanded.\n       */\n      case SPACE:\n      case RETURN:\n      case DOWN: {\n        if (popup) {\n          event.stopPropagation();\n          event.preventDefault();\n\n          if (! popup.state.expanded) {\n            popup.show();\n          }\n\n          popup.firstInteractiveChild.focus();\n        }\n\n        break;\n      }\n\n      /*\n       * Select the first MenuBar item.\n       */\n      case HOME: {\n        event.preventDefault();\n        const [firstItem] = this.menuBarItems;\n        this.setState({\n          menubarItem: firstItem,\n        });\n\n        break;\n      }\n\n      /*\n       * Select the last MenuBar item.\n       */\n      case END: {\n        event.preventDefault();\n        this.setState({\n          menubarItem: this.lastItem,\n        });\n\n        break;\n      }\n\n      /*\n       * Select the MenuBar item based on a search string created by\n       * collecting key presses.\n       */\n      default: {\n        const itemToFocus = this.search.getItem(keyCode);\n        if (null !== itemToFocus) {\n          this.setState({ menubarItem: itemToFocus });\n        }\n\n        break;\n      }\n    }\n  }\n\n  /**\n   * Update the active descendant when the item is clicked.\n   *\n   * @param {Object} event The event object.\n   */\n  menubarHandleClick(event) {\n    this.setState({\n      menubarItem: event.target,\n    });\n  }\n\n  /**\n   * Handle keydown events on sublist menuitems.\n   *\n   * @param {Object} event The event object.\n   */\n  menuItemHandleKeydown(event) {\n    const { SPACE, RETURN } = keyCodes;\n    const { keyCode, target } = event;\n\n    if ([SPACE, RETURN].includes(keyCode) && 'A' === target.nodeName) {\n      event.stopPropagation();\n      event.preventDefault();\n\n      // Simulate a mouse event to activate the menuitem.\n      target.dispatchEvent(this.clickEvent);\n    }\n  }\n\n  /**\n   * Recursively destroy MenuBar and Popups.\n   */\n  destroy() {\n    // Remove the reference to the class instance.\n    this.deleteSelfReferences();\n\n    // Remove the menu role.\n    this.list.removeAttribute('role');\n\n    this.menuBarItems.forEach((link) => {\n      // Remove list item role.\n      link.parentElement.removeAttribute('role');\n\n      // Remove size and position attributes.\n      link.removeAttribute('aria-setsize');\n      link.removeAttribute('aria-posinset');\n      link.removeAttribute('role');\n\n      // Remove event listeners.\n      link.parentElement.removeEventListener(\n        'keydown',\n        this.menubarHandleKeydown\n      );\n      link.removeEventListener('click', this.menubarHandleClick);\n    });\n\n    // Remove tabindex attribute.\n    tabIndexAllow(this.menuBarItems);\n\n    // Destroy popups.\n    this.popups.forEach((popup) => {\n      popup.target.removeEventListener('keydown', this.menuItemHandleKeydown);\n\n      popup.destroy();\n    });\n\n    // Destroy subMenus.\n    this.subMenus.forEach((submenu) => {\n      submenu.destroy();\n    });\n\n    // Run {destroyCallback}\n    this.onDestroy.call(this);\n  }\n}\n","import AriaComponent from '../AriaComponent';\nimport Popup from '../Popup';\nimport interactiveChildren from '../lib/interactiveChildren';\nimport keyCodes from '../lib/keyCodes';\nimport getFirstAndLastItems from '../lib/getFirstAndLastItems';\nimport toArray from '../lib/toArray';\n\n/**\n * Class to set up an interactive Dialog element.\n */\nexport default class Dialog extends AriaComponent {\n  /**\n   * Create a Dialog.\n   * @constructor\n   *\n   * @param {HTMLElement} controller The activating element.\n   * @param {object}      options    The options object.\n   */\n  constructor(controller, options = {}) {\n    super(controller);\n\n    this.controller = controller;\n    this.target = super.constructor.getTargetElement(controller);\n\n    /**\n     * The component name.\n     *\n     * @type {string}\n     */\n    this.componentName = 'Dialog';\n\n    /**\n     * Options shape.\n     *\n     * @type {object}\n     */\n    const defaultOptions = {\n      /**\n       * The element(s) to be hidden when the Dialog is visible. The elements\n       * wrapping all site content with the sole exception of the dialog element.\n       *\n       * @type {HTMLElement|NodeList|Array}\n       */\n      content: [],\n\n      /**\n       * Callback to run after the component initializes.\n       *\n       * @callback initCallback\n       */\n      onInit: () => {},\n\n      /**\n       * Callback to run after component state is updated.\n       *\n       * @callback stateChangeCallback\n       */\n      onStateChange: () => {},\n\n      /**\n       * Callback to run after the component is destroyed.\n       *\n       * @callback destroyCallback\n       */\n      onDestroy: () => {},\n    };\n\n    // Merge remaining options with defaults and save all as instance properties.\n    Object.assign(this, { ...defaultOptions, ...options });\n\n    // Get the content items if none are provided.\n    if (0 === this.content.length || undefined === this.content) {\n      this.content = Array.from(document.body.children)\n        .filter((child) => ! child.contains(this.target));\n    } else {\n      this.content = toArray(this.content);\n    }\n\n    // If no content is found.\n    if (0 === this.content.length) {\n      AriaComponent.configurationError(\n        'The Dialog target should not be within the main site content'\n      );\n    }\n\n    // Bind class methods\n    this.onPopupStateChange = this.onPopupStateChange.bind(this);\n    this.targetHandleKeydown = this.targetHandleKeydown.bind(this);\n    this.handleKeydownEsc = this.handleKeydownEsc.bind(this);\n    this.show = this.show.bind(this);\n    this.hide = this.hide.bind(this);\n    this.destroy = this.destroy.bind(this);\n    this.stateWasUpdated = this.stateWasUpdated.bind(this);\n\n    this.init();\n  }\n\n  /**\n   * Set the component's DOM attributes and event listeners.\n   */\n  init() {\n    /*\n     * A reference to the class instance added to the controller and target\n     * elements to enable external interactions with this instance.\n     */\n    super.setSelfReference([this.controller, this.target]);\n\n    /**\n     * The Popup instance controlling the Dialog.\n     *\n     * @type {Popup}\n     */\n    this.popup = new Popup(\n      this.controller,\n      {\n        type: 'dialog',\n        onStateChange: this.onPopupStateChange,\n      }\n    );\n\n    // Allow focus on the target element.\n    this.target.setAttribute('tabindex', '0');\n\n    /*\n     * Collect the Dialog's interactive child elements. This is an initial pass\n     * to ensure values exists, but the interactive children will be collected\n     * each time the dialog opens, in case the dialog's contents change.\n     */\n    this.interactiveChildElements = interactiveChildren(this.target);\n\n    // Add event listeners.\n    this.target.addEventListener('keydown', this.targetHandleKeydown);\n\n    /*\n     * Remove clashing Popup event listener. This Popup event listener is\n     * clashing with the Dialog's ability to trap keyboard tabs.\n     */\n    this.popup.target.removeEventListener(\n      'keydown',\n      this.popup.targetHandleKeydown\n    );\n\n    /**\n     * Set initial state.\n     *\n     * @type {object}\n     */\n    this.state = { expanded: false };\n\n    /* Run {initCallback} */\n    this.onInit.call(this);\n  }\n\n  /**\n   * Keep this component's state synced with the Popup's state.\n   *\n   * @param {Object} state The Popup state.\n   */\n  onPopupStateChange({ expanded }) {\n    this.setState({ expanded });\n  }\n\n  /**\n   * Update element attributes and event listeners when the Popup's state changes.\n   *\n   * @param {Object} state The component state.\n   */\n  stateWasUpdated() {\n    const { expanded } = this.state;\n    const contentLength = this.content.length;\n\n    this.interactiveChildElements = interactiveChildren(this.target);\n\n    if (expanded) {\n      for (let i = 0; i < contentLength; i += 1) {\n        this.content[i].setAttribute('aria-hidden', 'true');\n      }\n      document.body.addEventListener('keydown', this.handleKeydownEsc);\n      this.target.focus();\n    } else {\n      for (let i = 0; i < contentLength; i += 1) {\n        this.content[i].setAttribute('aria-hidden', 'false');\n      }\n      document.body.removeEventListener('keydown', this.handleKeydownEsc);\n      this.controller.focus();\n    }\n\n    /* Run {stateChangeCallback} */\n    this.onStateChange.call(this, this.state);\n  }\n\n  /**\n   * Close the dialog on when users click outside of the Dialog element.\n   *\n   * @param {Event} event The Event object.\n   */\n  outsideClick(event) {\n    const { expanded } = this.state;\n\n    if (expanded && ! this.target.contains(event.target)) {\n      this.hide();\n    }\n  }\n\n  /**\n   * Trap key tabs within the dialog.\n   *\n   * @param {Event} event The Event object.\n   */\n  targetHandleKeydown(event) {\n    const { TAB } = keyCodes;\n    const { keyCode, shiftKey } = event;\n    const { expanded } = this.state;\n\n    if (expanded && keyCode === TAB) {\n      const { activeElement } = document;\n      const [\n        firstInteractiveChild,\n        lastInteractiveChild,\n      ] = getFirstAndLastItems(this.interactiveChildElements);\n\n      if (shiftKey && firstInteractiveChild === activeElement) {\n        event.preventDefault();\n        /*\n         * Move back from the first interactive child element to the last\n         * interactive child element\n         */\n        lastInteractiveChild.focus();\n      } else if (! shiftKey && lastInteractiveChild === activeElement) {\n        event.preventDefault();\n        /*\n         * Move forward from the last interactive child element to the first\n         * interactive child element.\n         */\n        firstInteractiveChild.focus();\n      }\n    }\n  }\n\n  /**\n   * Close the dialog on ESC key press. This is added to the body element, so\n   * any press of the ESC key will short-circuit the dialog and move forcus back\n   * to the controller.\n   *\n   * @param {Event} event The Event object.\n   */\n  handleKeydownEsc(event) {\n    const { ESC } = keyCodes;\n    const { keyCode } = event;\n\n    if (ESC === keyCode) {\n      this.hide();\n    }\n  }\n\n  /**\n   * Destroy the Dialog and Popup.\n   */\n  destroy() {\n    // Remove the references to the class instance.\n    this.deleteSelfReferences();\n\n    // Destroy the Dialog Popup.\n    this.popup.destroy();\n\n    // Remove the `aria-hidden` attribute from the content wrapper.\n    const contentLength = this.content.length;\n    for (let i = 0; i < contentLength; i += 1) {\n      this.content[i].removeAttribute('aria-hidden');\n    }\n\n    // Remove tabIndex attribute from target.\n    this.target.removeAttribute('tabindex');\n\n    // Remove event listeners.\n    this.target.removeEventListener('keydown', this.targetHandleKeydown);\n    document.body.removeEventListener('keydown', this.handleKeydownEsc);\n\n    /* Run {destroyCallback} */\n    this.onDestroy.call(this);\n  }\n\n  /**\n   * Show the Dialog.\n   */\n  show() {\n    this.popup.show();\n  }\n\n  /**\n   * Hide the Dialog.\n   */\n  hide() {\n    this.popup.hide();\n  }\n}\n","import AriaComponent from '../AriaComponent';\nimport interactiveChildren from '../lib/interactiveChildren';\nimport { setUniqueId } from '../lib/uniqueId';\nimport { tabIndexDeny, tabIndexAllow } from '../lib/rovingTabIndex';\nimport { nextPreviousFromLeftRight } from '../lib/nextPrevious';\nimport keyCodes from '../lib/keyCodes';\n\n/**\n * Class for implimenting a tabs widget for sectioning content and displaying\n * one at a time.\n *\n * https://www.w3.org/TR/wai-aria-practices-1.1/#tabpanel\n * https://www.w3.org/TR/wai-aria-practices-1.1/examples/tabs/tabs-1/tabs.html\n */\nexport default class Tablist extends AriaComponent {\n  /**\n   * Create a Tablist.\n   * @constructor\n   *\n   * @param {object} options The options object.\n   */\n  constructor(tabs, options) {\n    super(tabs);\n\n    if ('UL' !== tabs.nodeName) {\n      AriaComponent.configurationError(\n        'The component element nodeName must be `UL`'\n      );\n    }\n\n    this.tabs = tabs;\n\n    /**\n     * The component name.\n     *\n     * @type {string}\n     */\n    this.componentName = 'Tablist';\n\n    /**\n     * Component configuration options.\n     *\n     * @type {object}\n     */\n    const defaultOptions = {\n      /**\n       * Callback to run after the component initializes.\n       *\n       * @callback initCallback\n       */\n      onInit: () => {},\n\n      /**\n       * Callback to run after component state is updated.\n       *\n       * @callback stateChangeCallback\n       */\n      onStateChange: () => {},\n\n      /**\n       * Callback to run after the component is destroyed.\n       *\n       * @callback destroyCallback\n       */\n      onDestroy: () => {},\n    };\n\n    // Save references to the tablist and panels.\n    Object.assign(this, { ...defaultOptions, ...options });\n\n    // Intial component state.\n    this.state = { activeIndex: 0 };\n\n    // Bind class methods.\n    this.panelHandleKeydown = this.panelHandleKeydown.bind(this);\n    this.tabsHandleKeydown = this.tabsHandleKeydown.bind(this);\n    this.tabsHandleClick = this.tabsHandleClick.bind(this);\n    this.switchTo = this.switchTo.bind(this);\n    this.destroy = this.destroy.bind(this);\n    this.stateWasUpdated = this.stateWasUpdated.bind(this);\n\n    /**\n     * Collect the anchor inside of each list item. Using anchors makes\n     * providing a non-JS fallback as simple as using the associated tabpanel's\n     * ID attribute as the link's HREF.\n     *\n     * Required tab markup: `<li><a href=\"\"></a></li>`\n     *\n     * @type {array}\n     */\n    this.tabLinks = Array.from(this.tabs.children)\n      .filter((child) => null !== child.querySelector('a[href]'))\n      .map((child) => child.querySelector('a[href]'));\n\n    /**\n     * Tablist panels.\n     *\n     * @type {array}\n     */\n    this.panels = this.tabLinks.reduce((acc, tabLink) => {\n      const panel = document.getElementById(tabLink.hash.replace('#', ''));\n      if (null !== panel) {\n        return [...acc, panel];\n      }\n\n      return acc;\n    }, []);\n\n    // Only initialize if tabs and panels are equal in number.\n    if (this.tabLinks.length === this.panels.length) {\n      this.init();\n    }\n  }\n\n  /**\n   * Set up the component's DOM attributes and event listeners.\n   */\n  init() {\n    // Component state is initially set in the constructor.\n    const { activeIndex } = this.state;\n\n    /*\n     * The`tablist` role indicates that the list is a container for a set of tabs.\n     *\n     * https://www.w3.org/TR/wai-aria-1.1/#tablist\n     */\n    this.tabs.setAttribute('role', 'tablist');\n\n    /*\n     * Prevent the Tablist LI element from being announced as list-items as\n     * that information is neither useful nor applicable.\n     */\n    Array.from(this.tabs.children).forEach((listChild) => {\n      if ('LI' === listChild.nodeName) {\n        listChild.setAttribute('role', 'presentation');\n      }\n    });\n\n    // Set attributes for each tab.\n    this.tabLinks.forEach((tab, index) => {\n      /*\n       * A reference to the class instance added to the controller and target\n       * elements to enable external interactions with this instance.\n       */\n      super.setSelfReference([tab]);\n\n      // Ensure each tab has an ID.\n      setUniqueId(tab);\n      // Add the `tab` role to indicate its relationship to the Tablist.\n      tab.setAttribute('role', 'tab');\n\n      if (activeIndex !== index) {\n        // Don't allow focus on inactive tabs.\n        tab.setAttribute('tabindex', '-1');\n      } else {\n        // Set the first tab as selected by default.\n        tab.setAttribute('aria-selected', 'true');\n      }\n\n      tab.setAttribute('aria-controls', this.panels[index].id);\n    });\n\n    // Add event listeners.\n    this.tabs.addEventListener('click', this.tabsHandleClick);\n    this.tabs.addEventListener('keydown', this.tabsHandleKeydown);\n\n    // Set attributes or each panel.\n    this.panels.forEach((panel, index) => {\n      /*\n       * Add a reference to the class instance to enable external interactions\n       * with this instance.\n       */\n      super.setSelfReference([panel]);\n\n      // Ensure each panel has an ID.\n      setUniqueId(panel);\n      // Add the `tabpanel` role to indicate its relationship to the tablist.\n      panel.setAttribute('role', 'tabpanel');\n      // Create a relationship between the tab and its panel.\n      panel.setAttribute('aria-labelledby', this.tabLinks[index].id);\n      // All but the first tab should be hidden by default.\n      if (activeIndex === index) {\n        panel.setAttribute('tabindex', '0');\n        panel.setAttribute('aria-hidden', 'false');\n        panel.removeAttribute('hidden');\n      } else {\n        panel.setAttribute('aria-hidden', 'true');\n        panel.setAttribute('hidden', '');\n      }\n\n      // Listen for panel keydown events.\n      panel.addEventListener('keydown', this.panelHandleKeydown);\n    });\n\n    // Save the active panel's interactive children.\n    this.interactiveChildElements = interactiveChildren(this.panels[activeIndex]); // eslint-disable-line max-len\n\n    // Run {initCallback}\n    this.onInit.call(this);\n  }\n\n  /**\n   * Update tab and panel attributes based on component state.\n   *\n   * @param {object} state The component state.\n   * @param {number} state.activeIndex The active index of both tabs and panels.\n   */\n  stateWasUpdated() {\n    const { activeIndex } = this.state;\n\n    // Get the tab currently designated as `aria-selected`.\n    const [deactivate] = this.tabLinks.filter((tab) => (\n      'true' === tab.getAttribute('aria-selected')\n    ));\n    // Get the index; this is essentially the previous `activeIndex` state.\n    const deactiveIndex = this.tabLinks.indexOf(deactivate);\n\n    // Deactivate the previously-selected tab.\n    deactivate.setAttribute('tabindex', '-1');\n    deactivate.removeAttribute('aria-selected');\n    this.panels[deactiveIndex].setAttribute('aria-hidden', 'true');\n    this.panels[deactiveIndex].setAttribute('hidden', '');\n    this.panels[deactiveIndex].removeAttribute('tabindex');\n\n    // Prevent tabbing to interactive children of the deactivated panel.\n    const deactiveChildren = interactiveChildren(this.panels[deactiveIndex]);\n    tabIndexDeny(deactiveChildren);\n\n    // Actvate the newly active tab.\n    this.tabLinks[activeIndex].removeAttribute('tabindex');\n    this.tabLinks[activeIndex].setAttribute('aria-selected', 'true');\n    this.panels[activeIndex].setAttribute('aria-hidden', 'false');\n    this.panels[activeIndex].removeAttribute('hidden');\n    this.panels[activeIndex].setAttribute('tabindex', '0');\n\n    // Allow tabbing to the newly-active panel.\n    this.interactiveChildElements = interactiveChildren(this.panels[activeIndex]); // eslint-disable-line max-len\n    tabIndexAllow(this.interactiveChildElements);\n\n    // Run {stateChangeCallback}\n    this.onStateChange.call(this, this.state);\n  }\n\n  /**\n   * Handle keydown events on the tabpanels.\n   *\n   * @param {Event} event The event object.\n   */\n  panelHandleKeydown(event) {\n    const { TAB } = keyCodes;\n    const { activeIndex } = this.state;\n    const { keyCode, shiftKey } = event;\n    const { activeElement } = document;\n    const [firstInteractiveChild] = this.interactiveChildElements;\n\n    if (keyCode === TAB && shiftKey) {\n      if (activeElement === this.panels[activeIndex]) {\n        event.preventDefault();\n        this.tabLinks[activeIndex].focus();\n      } else if (activeElement === firstInteractiveChild) {\n        /*\n         * Ensure navigating with Shift-TAB from the first interactive child of\n         * the active panel returns focus to the active panel.\n         */\n        event.preventDefault();\n        this.panels[activeIndex].focus();\n      }\n    }\n  }\n\n  /**\n   * Handle tablist key presses.\n   *\n   * @param {Event} event The event object.\n   */\n  tabsHandleKeydown(event) {\n    const {\n      TAB,\n      LEFT,\n      RIGHT,\n      DOWN,\n      HOME,\n      END,\n    } = keyCodes;\n    const { keyCode, shiftKey, target } = event;\n    const currentIndex = this.tabLinks.indexOf(target);\n\n    switch (keyCode) {\n      /*\n       * Move focus from the active tab to the active panel.\n       */\n      case TAB: {\n        if (! shiftKey) {\n          event.preventDefault();\n\n          this.panels[currentIndex].focus();\n        }\n\n        break;\n      }\n\n      /*\n       * Move to and activate the previous or next tab.\n       */\n      case LEFT:\n      case RIGHT: {\n        const newItem = nextPreviousFromLeftRight(\n          keyCode,\n          target,\n          this.tabLinks\n        );\n\n        if (newItem) {\n          event.preventDefault();\n\n          this.switchTo(this.tabLinks.indexOf(newItem));\n          newItem.focus();\n        }\n\n        break;\n      }\n\n      /*\n       * Focus the active panel itself with the down arrow.\n       */\n      case DOWN: {\n        event.preventDefault();\n\n        this.panels[currentIndex].setAttribute('tabindex', '0');\n        this.panels[currentIndex].focus();\n\n        break;\n      }\n\n      /*\n       * Select the first Tablist tab.\n       */\n      case HOME: {\n        event.preventDefault();\n        this.switchTo(0);\n        this.tabLinks[0].focus();\n\n        break;\n      }\n\n      /*\n       * Select the last Tablist tab.\n       */\n      case END: {\n        event.preventDefault();\n        const lastIndex = this.tabLinks.length - 1;\n        this.switchTo(lastIndex);\n        this.tabLinks[lastIndex].focus();\n\n        break;\n      }\n\n      // fuggitaboutit.\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Activate the tab panel when a tab is clicked.\n   *\n   * @param {Event} event The event object.\n   */\n  tabsHandleClick(event) {\n    const { target } = event;\n    event.preventDefault();\n\n    // Don't act when an active tab is clicked.\n    if ('true' !== target.getAttribute('aria-selected')) {\n      if (this.tabLinks.includes(target)) {\n        this.switchTo(this.tabLinks.indexOf(target));\n      }\n    }\n  }\n\n  /**\n   * Switch directly to a tab.\n   *\n   * @param {number} index The zero-based tab index to activate.\n   */\n  switchTo(index) {\n    this.setState({ activeIndex: index });\n  }\n\n  /**\n   * Destroy the tablist, removing ARIA attributes and event listeners\n   */\n  destroy() {\n    // Remove the tablist role.\n    this.tabs.removeAttribute('role');\n\n    // Remove the 'presentation' role from each list item.\n    Array.from(this.tabs.children).forEach((listChild) => {\n      if ('LI' === listChild.nodeName) {\n        listChild.removeAttribute('role');\n      }\n    });\n\n    // Remove the references to the class instance.\n    this.deleteSelfReferences();\n\n    // Remove tab attributes and event listeners.\n    this.tabLinks.forEach((tab) => {\n      tab.removeAttribute('role');\n      tab.removeAttribute('aria-selected');\n      tab.removeAttribute('tabindex');\n      tab.removeAttribute('aria-controls');\n\n      tab.removeEventListener('click', this.tabsHandleClick);\n      tab.removeEventListener('keydown', this.tabsHandleKeydown);\n    });\n\n    // Remove panel attributes and event listeners.\n    this.panels.forEach((panel) => {\n      panel.removeAttribute('role');\n      panel.removeAttribute('aria-hidden');\n      panel.removeAttribute('hidden');\n      panel.removeAttribute('tabindex');\n      panel.removeAttribute('aria-labelledby');\n\n      // Make sure to allow tabbing to all children of all panels.\n      const interactiveChildElements = interactiveChildren(panel);\n      tabIndexAllow(interactiveChildElements);\n\n      panel.removeEventListener(\n        'keydown',\n        this.panelHandleKeydown\n      );\n    });\n\n    // Run {destroyCallback}\n    this.onDestroy.call(this);\n  }\n}\n","import AriaComponent from '../AriaComponent';\nimport Popup from '../Popup';\nimport Menu from '../Menu';\nimport keyCodes from '../lib/keyCodes';\n\n/**\n * Class to set up an interactive Menu Button element.\n *\n * https://www.w3.org/TR/wai-aria-practices-1.1/#menubutton\n * https://www.w3.org/TR/wai-aria-practices-1.1/examples/menu-button/menu-button-links.html\n */\nexport default class MenuButton extends AriaComponent {\n  /**\n   * Create a ListBox.\n   * @constructor\n   *\n   * @param {HTMLElement} controller The activating element.\n   * @param {object}      options    The options object.\n   */\n  constructor(controller, options = {}) {\n    super(controller);\n\n    this.controller = controller;\n    this.target = super.constructor.getTargetElement(controller);\n\n    /**\n     * The component name.\n     *\n     * @type {string}\n     */\n    this.componentName = 'MenuButton';\n\n    /**\n     * Options shape.\n     *\n     * @type {object}\n     */\n    const defaultOptions = {\n      /**\n       * The Menu element.\n       *\n       * @type {HTMLUListElement}\n       */\n      list: null,\n\n      /**\n       * Callback to run after the component initializes.\n       *\n       * @callback initCallback\n       */\n      onInit: () => {},\n\n      /**\n       * Callback to run after component state is updated.\n       *\n       * @callback stateChangeCallback\n       */\n      onStateChange: () => {},\n\n      /**\n       * Callback to run after the component is destroyed.\n       *\n       * @callback destroyCallback\n       */\n      onDestroy: () => {},\n    };\n\n    // Merge options with defaults.\n    Object.assign(this, { ...defaultOptions, ...options });\n\n    // Bind class methods.\n    this.controllerHandleKeydown = this.controllerHandleKeydown.bind(this);\n    this.onPopupStateChange = this.onPopupStateChange.bind(this);\n    this.show = this.show.bind(this);\n    this.hide = this.hide.bind(this);\n    this.destroy = this.destroy.bind(this);\n\n    this.init();\n  }\n\n  /**\n   * Set up the component's DOM attributes and event listeners.\n   */\n  init() {\n    /**\n     * The MenuButton is basically a Popup to present a Menu, so we instantiate\n     * a Popup and subscribe to state changes to act on the MenuButton when the\n     * Popup is shown and hidden.\n     *\n     * @type {Popup}\n     */\n    this.popup = new Popup(\n      this.controller,\n      {\n        type: 'menu',\n        onStateChange: this.onPopupStateChange,\n      }\n    );\n\n    // Initialize the Menu if we passed one in.\n    if (null != this.list && 'UL' === this.list.nodeName) {\n      this.menu = new Menu(this.list);\n    } else if ('UL' === this.target.nodeName) {\n      // Fallback to the target if it's a UL.\n      this.menu = new Menu(this.target);\n    } else {\n      const list = this.target.querySelector('ul');\n      this.menu = new Menu(list);\n    }\n\n    // Additional event listener(s).\n    this.controller.addEventListener('keydown', this.controllerHandleKeydown);\n\n    /**\n     * Set initial state.\n     *\n     * @type {object}\n     */\n    this.state = { expanded: false };\n\n    // Run {initCallback}\n    this.onInit.call(this);\n  }\n\n  /**\n   * Keep this component's state synced with the Popup's state.\n   *\n   * @param {Object} state The Popup state.\n   */\n  onPopupStateChange(state) {\n    this.setState(state);\n\n    // Run {stateChangeCallback}\n    this.onStateChange.call(this, this.state);\n  }\n\n  /**\n   * Handle keydown events on the MenuButton controller.\n   *\n   * @param {Event} event The event object.\n   */\n  controllerHandleKeydown(event) {\n    const { keyCode } = event;\n    const {\n      RETURN,\n      UP,\n      DOWN,\n      SPACE,\n    } = keyCodes;\n\n    switch (keyCode) {\n      /*\n       * Open the menu and move focus to the first menu item.\n       */\n      case RETURN:\n      case SPACE:\n      case DOWN: {\n        event.preventDefault();\n        this.show();\n\n        // Move focus to the first menu item.\n        if (this.menu.firstItem) {\n          this.menu.firstItem.focus();\n        }\n\n        break;\n      }\n\n      /*\n       * Opens the menu and move focus to the last menu item.\n       */\n      case UP: {\n        event.preventDefault();\n        this.show();\n\n        // Move focus to the last menu item.\n        if (this.menu.lastItem) {\n          this.menu.lastItem.focus();\n        }\n\n        break;\n      }\n\n      default:\n        break;\n    }\n  }\n\n  /**\n   * Destroy the Popup and Menu.\n   */\n  destroy() {\n    // Destroy the MenuButton Popup.\n    this.popup.destroy();\n\n    // Destroy the Menu.\n    this.menu.destroy();\n\n    // Remove event listener.\n    this.controller.removeEventListener(\n      'keydown',\n      this.controllerHandleKeydown\n    );\n\n    // Run {destroyCallback}\n    this.onDestroy.call(this);\n  }\n\n  /**\n   * Show the menu Popup.\n   */\n  show() {\n    this.popup.show();\n  }\n\n  /**\n   * Hide the menu Popup.\n   */\n  hide() {\n    this.popup.hide();\n  }\n}\n","import AriaComponent from './src/AriaComponent';\nimport Listbox from './src/Listbox';\nimport MenuBar from './src/MenuBar';\nimport Menu from './src/Menu';\nimport Popup from './src/Popup';\nimport Disclosure from './src/Disclosure';\nimport Dialog from './src/Dialog';\nimport Tablist from './src/Tablist';\nimport MenuButton from './src/MenuButton';\n\nexport {\n  AriaComponent,\n  Listbox,\n  MenuBar,\n  Menu,\n  Popup,\n  Disclosure,\n  Dialog,\n  Tablist,\n  MenuButton,\n};\n","/* eslint-disable no-unused-vars */\nimport getClassnames from \"../../js/getClassnames\";\nimport { Popup } from \"../../../../..\";\nimport \"./popup.scss\"; // Get the components hashed classnames.\n\nvar _getClassnames = getClassnames(siteClassNames.popup),\n    button = _getClassnames.button; // Get the elements.\n\n\nvar controller = document.querySelector(button); // Create the Popup.\n\nvar popup = new Popup(controller);","/* eslint-disable no-unused-vars */\nimport getClassnames from \"../../js/getClassnames\";\nimport { Tablist } from \"../../../../..\";\nimport \"./tablist.scss\"; // Get the components hashed classnames.\n\nvar _getClassnames = getClassnames(siteClassNames.tablist),\n    list = _getClassnames.list; // Get the elements.\n\n\nvar tabs = document.querySelector(list); // Create the Tablist.\n\nvar tablist = new Tablist(tabs);\nwindow.addEventListener('load', tablistHashCheck);\nwindow.addEventListener('hashchange', tablistHashCheck);\n/**\n * Check for a hash in the URL and activate the corresponding tab.\n */\n\nfunction tablistHashCheck() {\n  var hash = window.location.hash.replace('#', '');\n  var el = document.getElementById(hash);\n\n  if (null !== el && el.tablist instanceof Tablist) {\n    var index = tablist.panels.indexOf(el);\n\n    if (-1 < index) {\n      tablist.switchTo(index);\n      el.scrollIntoView({\n        behavior: 'smooth'\n      });\n    }\n  }\n}","/* eslint-disable no-unused-vars */\nimport getClassnames from \"../../js/getClassnames\";\nimport { Listbox } from \"../../../../..\";\nimport \"./listbox.scss\"; // Get the components hashed classnames.\n\nvar _getClassnames = getClassnames(siteClassNames.listbox),\n    button = _getClassnames.button; // Get the elements.\n\n\nvar controller = document.querySelector(button); // Create the Listbox.\n\nvar listbox = new Listbox(controller);","/* eslint-disable no-unused-vars */\nimport getClassnames from \"../../js/getClassnames\";\nimport { Menu } from \"../../../../..\";\nimport \"./menu.scss\"; // Get the components hashed classnames.\n\nvar _getClassnames = getClassnames(siteClassNames.menu),\n    list = _getClassnames.list; // Get the elements.\n\n\nvar menuList = document.querySelector(list); // Create the Menu.\n// Alteratively pass `collapse: true` to collapse submenus as Disclosures.\n\nvar menu = new Menu(menuList);","import getClassnames from \"../../js/getClassnames\";\nimport { Dialog } from \"../../../../..\";\nimport \"./dialog.scss\"; // Get the components hashed classnames.\n\nvar _getClassnames = getClassnames(siteClassNames.dialog),\n    link = _getClassnames.link,\n    closeButton = _getClassnames.closeButton;\n\nwindow.addEventListener('load', function () {\n  // Get the elements.\n  var controller = document.querySelector(link);\n  var close = document.querySelector(closeButton); // Create the Dialog.\n\n  var dialog = new Dialog(controller);\n  close.addEventListener('click', dialog.hide);\n});","/* eslint-disable no-unused-vars */\nimport getClassnames from \"../../js/getClassnames\";\nimport { MenuBar } from \"../../../../..\";\nimport \"./menubar.scss\"; // Get the components hashed classnames.\n\nvar _getClassnames = getClassnames(siteClassNames.menubar),\n    list = _getClassnames.list; // Get the elements.\n\n\nvar menuBarList = document.querySelector(list); // Create the MenuBar.\n\nvar menuBar = new MenuBar(menuBarList);","/* eslint-disable no-unused-vars */\nimport getClassnames from \"../../js/getClassnames\";\nimport { Disclosure } from \"../../../../..\";\nimport \"./disclosure.scss\"; // Get the components hashed classnames.\n\nvar _getClassnames = getClassnames(siteClassNames.disclosure),\n    button = _getClassnames.button,\n    info = _getClassnames.info; // Get the elements.\n\n\nvar controllers = document.querySelectorAll(button); // Create the Disclosures.\n\nvar disclosures = Array.from(controllers).map(function (controller, index) {\n  return new Disclosure(controller);\n});\nwindow.addEventListener('load', disclosureHashCheck);\nwindow.addEventListener('hashchange', disclosureHashCheck);\n/**\n * Check for a hash in the URL and open the corresponding disclosure.\n */\n\nfunction disclosureHashCheck() {\n  var hash = window.location.hash.replace('#', '');\n  var el = document.getElementById(hash);\n\n  if (null !== el && el.disclosure instanceof Disclosure) {\n    var disclosure = el.disclosure;\n    disclosure.open();\n    disclosure.controller.scrollIntoView({\n      behavior: 'smooth'\n    });\n  }\n}","/* eslint-disable no-unused-vars */\nimport getClassnames from \"../../js/getClassnames\";\nimport { MenuButton } from \"../../../../..\";\nimport \"./menubutton.scss\"; // Get the components hashed classnames.\n\nvar _getClassnames = getClassnames(siteClassNames.menubutton),\n    button = _getClassnames.button; // Get the elements.\n\n\nvar controller = document.querySelector(button); // Create the MenuButton.\n\nvar menuButton = new MenuButton(controller);","// Global Styles\nimport \"../src/scss/reset.scss\";\nimport \"../src/scss/index.scss\"; // Components.\n\nimport \"../src/components/popup\";\nimport \"../src/components/tablist\";\nimport \"../src/components/listbox\";\nimport \"../src/components/menu\";\nimport \"../src/components/dialog\";\nimport \"../src/components/menubar\";\nimport \"../src/components/disclosure\";\nimport \"../src/components/menubutton\";"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClFA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}